<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CorruCAD v1.7</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .section-title {
            font-size: 1.125rem; font-weight: 600; color: #374151;
            border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; margin-bottom: 1rem;
        }
        .final-quote-value { color: #4338ca; }
        canvas {
            display: block; background-color: #ffffff; border: 1px solid #e0e0e0;
        }
    </style>
        <script src="/_vercel/insights/script.js" defer></script>

</head>

<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const createRoot = ReactDOM.createRoot;

        // --- CorruCAD Precision Estimating Engine v1.7 ---
        const estimatingEngine = (() => {
            const calculateQuote = (inputs) => {
                const defaults = {
                    outerLiner: 0, innerLiner: 0, middleLiner: 0, medium1: 0, medium2: 0,
                    takeUpFactor1: 0, takeUpFactor2: 0, priceMsf: 0, blankAreaSqFt: 0,
                    quantity: 0, marginPercent: 0, printUpcharge: 0, setupFee: 0
                };
                const data = { ...defaults, ...inputs };
                const mediumWeight = (data.medium1 * data.takeUpFactor1) + (data.medium2 * data.takeUpFactor2);
                const totalFiberWeightLbsMsf = data.outerLiner + data.innerLiner + data.middleLiner + mediumWeight;
                const totalTonsPerMsf = totalFiberWeightLbsMsf / 2000;
                const pricePerTon = totalTonsPerMsf > 0 ? data.priceMsf / totalTonsPerMsf : 0;
                const boxWeightLbs = (data.blankAreaSqFt / 1000) * totalFiberWeightLbsMsf;
                const boxWeightTons = boxWeightLbs / 2000;
                const baseMaterialCost = boxWeightTons * pricePerTon;
                const marginAmount = baseMaterialCost * (data.marginPercent / 100);
                const finalCostPerBox = baseMaterialCost + marginAmount + data.printUpcharge;
                const totalCost = (finalCostPerBox * data.quantity) + data.setupFee;
                return {
                    pricePerTon, totalFiberWeightLbsMsf, boxWeightLbs, baseMaterialCost,
                    marginAmount, costPerBox: finalCostPerBox, totalCost
                };
            };
            return { calculate: calculateQuote };
        })();

        // --- Comprehensive Board Data Object with Price ---
        const boardData = {
            '32 ECT C': { type: 'singlewall', thickness: 3/16, flute: 'C', components: { outerLiner: 35, medium1: 23, innerLiner: 35 }, priceMsf: 58 },
            '32 ECT B': { type: 'singlewall', thickness: 1/8, flute: 'B', components: { outerLiner: 35, medium1: 23, innerLiner: 35 }, priceMsf: 58 },
            '44 ECT C': { type: 'singlewall', thickness: 3/16, flute: 'C', components: { outerLiner: 56, medium1: 23, innerLiner: 56 }, priceMsf: 79 },
            '44 ECT B': { type: 'singlewall', thickness: 1/8, flute: 'B', components: { outerLiner: 56, medium1: 23, innerLiner: 56 }, priceMsf: 79 },
            '48 ECT BC': { type: 'doublewall', thickness: 5/16, flutes: ['B', 'C'], components: { outerLiner: 35, medium1: 23, middleLiner: 23, medium2: 23, innerLiner: 35 }, priceMsf: 102 },
            '51 ECT BC': { type: 'doublewall', thickness: 5/16, flutes: ['B', 'C'], components: { outerLiner: 35, medium1: 23, middleLiner: 35, medium2: 23, innerLiner: 35 }, priceMsf: 110 },
            '61 ECT BC': { type: 'doublewall', thickness: 5/16, flutes: ['B', 'C'], components: { outerLiner: 56, medium1: 23, middleLiner: 35, medium2: 23, innerLiner: 56 }, priceMsf: 128 },
            '71 ECT BC': { type: 'doublewall', thickness: 5/16, flutes: ['B', 'C'], components: { outerLiner: 56, medium1: 23, middleLiner: 56, medium2: 23, innerLiner: 56 }, priceMsf: 142 },
        };

        // NEW: Top Ten SKUs from CSV
        const topTenSkus = [
            { name: "6 x 6 x 6 (S-4062)", l: 6, w: 6, h: 6 },
            { name: "8 x 8 x 8 (S-4084)", l: 8, w: 8, h: 8 },
            { name: "10 x 10 x 10 (S-4105)", l: 10, w: 10, h: 10 },
            { name: "12 x 12 x 12 (S-4125)", l: 12, w: 12, h: 12 },
            { name: "14 x 14 x 14 (S-4142)", l: 14, w: 14, h: 14 },
            { name: "16 x 16 x 16 (S-4166)", l: 16, w: 16, h: 16 },
            { name: "18 x 12 x 12 (S-4181)", l: 18, w: 12, h: 12 },
            { name: "18 x 18 x 18 (S-4185)", l: 18, w: 18, h: 18 },
            { name: "20 x 20 x 20 (S-4201)", l: 20, w: 20, h: 20 },
            { name: "24 x 12 x 12 (S-4243)", l: 24, w: 12, h: 12 }
        ];

        // --- Start of STABLE Geometry and Drawing Engine ---
        const roundToNearestFraction = (valueInInches, fraction) => Math.ceil(valueInInches / fraction) * fraction;

        const fefcoStyles = {
            '0201': {
                name: 'Regular Slotted Container (RSC)',
                calculateBlank: (L_input, W_input, H_input, thickness) => {
                    const glueFlap = 1.375; const slotWidth_full_in = 3/8; const slotWidth_half_in = 3/16; const oneSixteenth_in = 1/16; const angle15DegRad = 15 * Math.PI / 180;
                    const panel1_width = L_input + thickness - oneSixteenth_in; const panel2_width = W_input + thickness; const panel3_width = L_input + thickness; const panel4_width = W_input + thickness - oneSixteenth_in;
                    const x_inner_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width; const x_outer_glue_tab = x_inner_glue_tab + glueFlap; const x_panel4_end_before_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width;
                    const internalH_for_blank = H_input + (2 * thickness);
                    const halfW = W_input / 2; const halfCal = thickness / 2;
                    const minorFlapLength_inches = roundToNearestFraction(halfW, 1/16) + roundToNearestFraction(halfCal, 1/16);
                    const blankWidth = x_outer_glue_tab; const blankHeight = internalH_for_blank + (2 * minorFlapLength_inches);
                    const angleOffset = Math.tan(angle15DegRad) * glueFlap;
                    const y_top_body_crease = minorFlapLength_inches; const y_bottom_body_crease = internalH_for_blank + minorFlapLength_inches;
                    const glueTabPoints = [ { x: x_inner_glue_tab, y: y_top_body_crease }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_inner_glue_tab, y: y_bottom_body_crease } ];
                    const dxfGlueTabPerimeterPoints = [ { x: x_panel4_end_before_glue_tab, y: y_bottom_body_crease }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_panel4_end_before_glue_tab, y: y_top_body_crease } ];
                    const glueTabScoreLine = { x1: x_inner_glue_tab, y1: y_top_body_crease, x2: x_inner_glue_tab, y2: y_bottom_body_crease };
                    const outsideDimensions = { length: L_input + (2 * thickness), width: W_input + (2 * thickness), height: H_input + (3 * thickness) };
                    const slots = [ { x: panel1_width - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' }, { x: x_inner_glue_tab - slotWidth_half_in, y: 0, w: slotWidth_half_in, h: minorFlapLength_inches, type: 'half_right_open' }, { x: panel1_width - (slotWidth_full_in / 2), y: internalH_for_blank + minorFlapLength_inches, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: internalH_for_blank + minorFlapLength_inches, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: internalH_for_blank + minorFlapLength_inches, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' }, { x: x_inner_glue_tab - slotWidth_half_in, y: internalH_for_blank + minorFlapLength_inches, w: slotWidth_half_in, h: minorFlapLength_inches, type: 'half_right_open' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: minorFlapLength_inches, w: panel1_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width, y: minorFlapLength_inches, w: panel2_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width, y: minorFlapLength_inches, w: panel3_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width + panel3_width, y: minorFlapLength_inches, w: panel4_width, h: internalH_for_blank, type: 'panel' }, { points: glueTabPoints, type: 'polygon_cut' }, { x: 0, y: 0, w: panel1_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width, y: 0, w: panel2_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: 0, w: panel3_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: 0, w: panel4_width, h: minorFlapLength_inches, type: 'flap' }, { x: 0, y: internalH_for_blank + minorFlapLength_inches, w: panel1_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width, y: internalH_for_blank + minorFlapLength_inches, w: panel2_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: internalH_for_blank + minorFlapLength_inches, w: panel3_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: internalH_for_blank + minorFlapLength_inches, w: panel4_width, h: minorFlapLength_inches, type: 'flap' }, ], scoreLines: [ { x1: panel1_width, y1: 0, x2: panel1_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width, y1: 0, x2: panel1_width + panel2_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width + panel3_width, y1: 0, x2: panel1_width + panel2_width + panel3_width, y2: blankHeight, type: 'vertical' }, { x1: glueTabScoreLine.x1, y1: glueTabScoreLine.y1, x2: glueTabScoreLine.x2, y2: glueTabScoreLine.y2, type: 'vertical_glue_tab' }, { x1: 0, y1: minorFlapLength_inches, x2: blankWidth, y2: minorFlapLength_inches, type: 'horizontal' }, { x1: 0, y1: internalH_for_blank + minorFlapLength_inches, x2: blankWidth, y2: internalH_for_blank + minorFlapLength_inches, type: 'horizontal' }, ], dxfGlueTabPerimeterPoints, slots };
                }
            },
            '0203': {
                name: 'Full Overlap Container (FOL)',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const glueFlap = 1.375; const slotWidth_full_in = 3/8; const slotWidth_half_in = 3/16; const oneSixteenth_in = 1/16; const angle15DegRad = 15 * Math.PI / 180;
                    const panel1_width = L_in + thickness - oneSixteenth_in; const panel2_width = W_in + thickness; const panel3_width = L_in + thickness; const panel4_width = W_in + thickness - oneSixteenth_in;
                    const x_inner_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width; const x_outer_glue_tab = x_inner_glue_tab + glueFlap; const x_panel4_end_before_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width;
                    const internalH_for_blank = H_in + (3 * thickness);
                    const majorFlapLength_inches = W_in;
                    const blankWidth = x_outer_glue_tab; const blankHeight = internalH_for_blank + (2 * majorFlapLength_inches);
                    const angleOffset = Math.tan(angle15DegRad) * glueFlap;
                    const y_top_body_crease = majorFlapLength_inches; const y_bottom_body_crease = internalH_for_blank + majorFlapLength_inches;
                    const glueTabPoints = [ { x: x_inner_glue_tab, y: y_top_body_crease }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_inner_glue_tab, y: y_bottom_body_crease } ];
                    const dxfGlueTabPerimeterPoints = [ { x: x_panel4_end_before_glue_tab, y: y_bottom_body_crease }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_panel4_end_before_glue_tab, y: y_top_body_crease } ];
                    const glueTabScoreLine = { x1: x_inner_glue_tab, y1: y_top_body_crease, x2: x_inner_glue_tab, y2: y_bottom_body_crease };
                    const outsideDimensions = { length: L_in + (2 * thickness), width: W_in + (2 * thickness), height: H_in + (4 * thickness) };
                    const slots = [ { x: panel1_width - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: x_inner_glue_tab - slotWidth_half_in, y: 0, w: slotWidth_half_in, h: majorFlapLength_inches, type: 'half_right_open' }, { x: panel1_width - (slotWidth_full_in / 2), y: internalH_for_blank + majorFlapLength_inches, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: internalH_for_blank + majorFlapLength_inches, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: internalH_for_blank + majorFlapLength_inches, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: x_inner_glue_tab - slotWidth_half_in, y: internalH_for_blank + majorFlapLength_inches, w: slotWidth_half_in, h: majorFlapLength_inches, type: 'half_right_open' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: majorFlapLength_inches, w: panel1_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width, y: majorFlapLength_inches, w: panel2_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width, y: majorFlapLength_inches, w: panel3_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width + panel3_width, y: majorFlapLength_inches, w: panel4_width, h: internalH_for_blank, type: 'panel' }, { points: glueTabPoints, type: 'polygon_cut' }, { x: 0, y: 0, w: panel1_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width, y: 0, w: panel2_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: 0, w: panel3_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: 0, w: panel4_width, h: majorFlapLength_inches, type: 'flap' }, { x: 0, y: internalH_for_blank + majorFlapLength_inches, w: panel1_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width, y: internalH_for_blank + majorFlapLength_inches, w: panel2_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: internalH_for_blank + majorFlapLength_inches, w: panel3_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: internalH_for_blank + majorFlapLength_inches, w: panel4_width, h: majorFlapLength_inches, type: 'flap' }, ], scoreLines: [ { x1: panel1_width, y: 0, x2: panel1_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width, y: 0, x2: panel1_width + panel2_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width + panel3_width, y: 0, x2: panel1_width + panel2_width + panel3_width, y2: blankHeight, type: 'vertical' }, { x1: glueTabScoreLine.x1, y1: glueTabScoreLine.y1, x2: glueTabScoreLine.x2, y2: glueTabScoreLine.y2, type: 'vertical_glue_tab' }, { x1: 0, y1: majorFlapLength_inches, x2: blankWidth, y2: majorFlapLength_inches, type: 'horizontal' }, { x1: 0, y1: internalH_for_blank + majorFlapLength_inches, x2: blankWidth, y2: internalH_for_blank + majorFlapLength_inches, type: 'horizontal' }, ], dxfGlueTabPerimeterPoints, slots };
                }
            },
            '0200_HSC': {
                name: 'Half-Slotted Container (HSC)',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const glueFlap_in = 1.375; const slotWidth_full_in = 3/8; const slotWidth_half_in = 3/16; const oneSixteenth_in = 1/16; const angle15DegRad = 15 * Math.PI / 180;
                    const panel1_width = L_in + thickness - oneSixteenth_in; const panel2_width = W_in + thickness; const panel3_width = L_in + thickness; const panel4_width = W_in + thickness - oneSixteenth_in;
                    const x_inner_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width; const x_outer_glue_tab = x_inner_glue_tab + glueFlap_in; const x_panel4_end_before_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width;
                    const internalH_for_blank = H_in + (1 * thickness);
                    const halfW = W_in / 2; const halfCal = thickness / 2;
                    const flapLength_inches = roundToNearestFraction(halfW, 1/16) + roundToNearestFraction(halfCal, 1/16);
                    const blankWidth = x_outer_glue_tab; const blankHeight = internalH_for_blank + flapLength_inches;
                    const angleOffset = Math.tan(angle15DegRad) * glueFlap_in;
                    const y_top_body_crease = 0; const y_bottom_body_crease = internalH_for_blank;
                    const glueTabPoints = [ { x: x_inner_glue_tab, y: y_top_body_crease }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_inner_glue_tab, y: y_bottom_body_crease } ];
                    const dxfGlueTabPerimeterPoints = [ { x: x_panel4_end_before_glue_tab, y: y_bottom_body_crease }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_panel4_end_before_glue_tab, y: y_top_body_crease } ];
                    const glueTabScoreLine = { x1: x_inner_glue_tab, y1: y_top_body_crease, x2: x_inner_glue_tab, y2: y_bottom_body_crease };
                    const outsideDimensions = { length: L_in + (2 * thickness), width: W_in + (2 * thickness), height: H_in + (2 * thickness) };
                    const slots = [ { x: panel1_width - (slotWidth_full_in / 2), y: internalH_for_blank, w: slotWidth_full_in, h: flapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: internalH_for_blank, w: slotWidth_full_in, h: flapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: internalH_for_blank, w: slotWidth_full_in, h: flapLength_inches, type: 'full' }, { x: x_inner_glue_tab - slotWidth_half_in, y: internalH_for_blank, w: slotWidth_half_in, h: flapLength_inches, type: 'half_right_open' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: 0, w: panel1_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width, y: 0, w: panel2_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width, y: 0, w: panel3_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width + panel3_width, y: 0, w: panel4_width, h: internalH_for_blank, type: 'panel' }, { points: glueTabPoints, type: 'polygon_cut' }, { x: 0, y: internalH_for_blank, w: panel1_width, h: flapLength_inches, type: 'flap' }, { x: panel1_width, y: internalH_for_blank, w: panel2_width, h: flapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: internalH_for_blank, w: panel3_width, h: flapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: internalH_for_blank, w: panel4_width, h: flapLength_inches, type: 'flap' }, ], scoreLines: [ { x1: panel1_width, y: 0, x2: panel1_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width, y: 0, x2: panel1_width + panel2_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width + panel3_width, y: 0, x2: panel1_width + panel2_width + panel3_width, y2: blankHeight, type: 'vertical' }, { x1: glueTabScoreLine.x1, y1: glueTabScoreLine.y1, x2: glueTabScoreLine.x2, y2: glueTabScoreLine.y2, type: 'vertical_glue_tab' }, { x1: 0, y1: internalH_for_blank, x2: blankWidth, y2: internalH_for_blank, type: 'horizontal' }, ], slots, dxfGlueTabPerimeterPoints };
                }
            },
            '0501': {
                name: 'Glued Tube (FEFCO 0501)',
                calculateBlank: (L_input, W_input, H_input, thickness) => {
                    const oneSixteenth_in = 1/16; const glueFlap_in = 1.375; const angle15DegRad = 15 * Math.PI / 180;
                    const panel1_width = L_input + thickness - oneSixteenth_in; const panel2_width = W_input + thickness; const panel3_width = L_input + thickness; const panel4_width = W_input + thickness - oneSixteenth_in;
                    const x_inner_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width; const x_outer_glue_tab = x_inner_glue_tab + glueFlap_in; const x_panel4_end_before_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width;
                    const internalH_for_blank = H_input;
                    const blankWidth = x_outer_glue_tab; const blankHeight = internalH_for_blank;
                    const angleOffset = Math.tan(angle15DegRad) * glueFlap_in;
                    const y_top_body_crease = 0; const y_bottom_body_crease = internalH_for_blank;
                    const glueTabPoints = [ { x: x_inner_glue_tab, y: y_top_body_crease }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_inner_glue_tab, y: y_bottom_body_crease } ];
                    const dxfGlueTabPerimeterPoints = [ { x: x_panel4_end_before_glue_tab, y: y_bottom_body_crease }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_panel4_end_before_glue_tab, y: y_top_body_crease } ];
                    const glueTabScoreLine = { x1: x_inner_glue_tab, y1: y_top_body_crease, x2: x_inner_glue_tab, y2: y_bottom_body_crease };
                    const outsideDimensions = { length: L_input + (2 * thickness), width: W_input + (2 * thickness), height: H_input };
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: 0, w: panel1_width, h: blankHeight, type: 'panel' }, { x: panel1_width, y: 0, w: panel2_width, h: blankHeight, type: 'panel' }, { x: panel1_width + panel2_width, y: 0, w: panel3_width, h: blankHeight, type: 'panel' }, { x: panel1_width + panel2_width + panel3_width, y: 0, w: panel4_width, h: blankHeight, type: 'panel' }, { points: glueTabPoints, type: 'polygon_cut' } ], scoreLines: [ { x1: panel1_width, y: 0, x2: panel1_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width, y: 0, x2: panel1_width + panel2_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width + panel3_width, y: 0, x2: panel1_width + panel2_width + panel3_width, y2: blankHeight, type: 'vertical' }, { x1: glueTabScoreLine.x1, y1: glueTabScoreLine.y1, x2: glueTabScoreLine.x2, y2: glueTabScoreLine.y2, type: 'vertical_glue_tab' } ], slots: [], dxfGlueTabPerimeterPoints };
                }
            },
            '0301_TRAY': {
                name: '0301 Design Style Tray (Base)',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const D = H_in; const CAL = thickness; const frac = 1/16; const slot_width = 3/8;
                    const flap_H = roundToNearestFraction(D + 0.5 * CAL, frac); const flap_W = roundToNearestFraction(D + 0.5 * CAL, frac);
                    const center_L = roundToNearestFraction(L_in + 2 * CAL, frac); const center_W = roundToNearestFraction(W_in + 1 * CAL, frac);
                    const blankWidth = flap_W + center_L + flap_W; const blankHeight = flap_H + center_W + flap_H;
                    const outsideDimensions = { length: center_L, width: center_W, height: flap_H };
                    const slots = [ { x: flap_W - (slot_width / 2), y: 0, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W + center_L - (slot_width / 2), y: 0, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W - (slot_width / 2), y: flap_H + center_W, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W + center_L - (slot_width / 2), y: flap_H + center_W, w: slot_width, h: flap_H, type: 'full' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: 0, w: blankWidth, h: blankHeight, type: 'panel' } ], scoreLines: [ { x1: flap_W, y1: 0, x2: flap_W, y2: blankHeight, type: 'vertical' }, { x1: flap_W + center_L, y1: 0, x2: flap_W + center_L, y2: blankHeight, type: 'vertical' }, { x1: 0, y1: flap_H, x2: blankWidth, y2: flap_H, type: 'horizontal' }, { x1: 0, y1: flap_H + center_W, x2: blankWidth, y2: flap_H + center_W, type: 'horizontal' }, ], slots, dxfGlueTabPerimeterPoints: [] };
                }
            },
            '0301_LID': {
                name: '0301 Design Style Lid',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const D = H_in; const CAL = thickness; const frac = 1/16; const slot_width = 3/8;
                    const flap_H = roundToNearestFraction(D + 1.5 * CAL, frac); const flap_W = roundToNearestFraction(D + 1.5 * CAL, frac);
                    const center_L = roundToNearestFraction(W_in + 7 * CAL, frac); const center_W = roundToNearestFraction(L_in + 5 * CAL, frac);
                    const blankWidth = flap_W + center_L + flap_W; const blankHeight = flap_H + center_W + flap_H;
                    const outsideDimensions = { length: center_L, width: center_W, height: flap_H };
                    const slots = [ { x: flap_W - (slot_width / 2), y: 0, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W + center_L - (slot_width / 2), y: 0, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W - (slot_width / 2), y: flap_H + center_W, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W + center_L - (slot_width / 2), y: flap_H + center_W, w: slot_width, h: flap_H, type: 'full' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: 0, w: blankWidth, h: blankHeight, type: 'panel' } ], scoreLines: [ { x1: flap_W, y1: 0, x2: flap_W, y2: blankHeight, type: 'vertical' }, { x1: flap_W + center_L, y1: 0, x2: flap_W + center_L, y2: blankHeight, type: 'vertical' }, { x1: 0, y1: flap_H, x2: blankWidth, y2: flap_H, type: 'horizontal' }, { x1: 0, y1: flap_H + center_W, x2: blankWidth, y2: flap_H + center_W, type: 'horizontal' }, ], slots, dxfGlueTabPerimeterPoints: [] };
                }
            },
            '0401': {
                name: 'One Piece Folder (0401)',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const CAL = thickness;
                    const corner_offset = 0.5 * CAL; 

                    // --- Horizontal (X) Dimensions ---
                    // Layout: Tuck | Side Depth | Main Length | Side Depth | Tuck
                    const Tuck = 2.0; 
                    const x_tuck_w = Tuck;
                    const x_depth_w = H_in + CAL; 
                    const x_length_w = L_in + CAL; 

                    const x0 = 0;
                    const x1 = x0 + x_tuck_w;
                    const x2 = x1 + x_depth_w;   // Start of Main Panel
                    const x3 = x2 + x_length_w;  // End of Main Panel
                    const x4 = x3 + x_depth_w;
                    const x5 = x4 + x_tuck_w;
                    const blankWidth = x5;

                    // --- Vertical (Y) Dimensions ---
                    // Layout: Top Lid | Top Depth | Main Width | Bottom Depth | Bottom Lid
                    // Note: We restore the explicit Depth panels here.
                    const y_lid_h = (W_in / 2);    // Meets in middle
                    const y_depth_h = H_in + CAL;  // Depth panel height
                    const y_main_h = W_in + (2 * CAL); 

                    const y0 = 0;
                    const y1 = y0 + y_lid_h;        // Score: Top Lid -> Top Depth
                    const y2 = y1 + y_depth_h;      // Score: Top Depth -> Main (Top Edge of Main)
                    const y3 = y2 + y_main_h;       // Score: Main -> Bottom Depth (Bottom Edge of Main)
                    const y4 = y3 + y_depth_h;      // Score: Bottom Depth -> Bottom Lid
                    const y5 = y4 + y_lid_h;        // End
                    const blankHeight = y5;

                    // --- Wing Geometry Fix ---
                    // The Side Wings (attached to Main) must be shorter than the Main Panel height
                    // by 0.5 CAL at top and bottom to allow folding inside the Top/Bottom Depth panels.
                    const y_wing_top = y2 + corner_offset;
                    const y_wing_bottom = y3 - corner_offset;
                    const h_wing = y_wing_bottom - y_wing_top;

                    const outsideDimensions = { 
                        length: L_in + (2 * CAL), 
                        width: W_in + (2 * CAL), 
                        height: H_in + (2 * CAL) 
                    };

                    const layout = [
                        // Central Main Panel
                        { x: x2, y: y2, w: x_length_w, h: y_main_h, type: 'panel' },

                        // Vertical Strip Panels (Top/Bottom)
                        { x: x2, y: 0, w: x_length_w, h: y_lid_h, type: 'flap' },        // Top Lid
                        { x: x2, y: y1, w: x_length_w, h: y_depth_h, type: 'panel' },    // Top Depth (Restored)
                        { x: x2, y: y3, w: x_length_w, h: y_depth_h, type: 'panel' },    // Bottom Depth (Restored)
                        { x: x2, y: y4, w: x_length_w, h: y_lid_h, type: 'flap' },       // Bottom Lid

                        // Horizontal Strip Panels (Wings) - with offset height
                        { x: x0, y: y_wing_top, w: x_tuck_w, h: h_wing, type: 'flap' },  // Left Tuck
                        { x: x1, y: y_wing_top, w: x_depth_w, h: h_wing, type: 'panel' },// Left Depth
                        { x: x3, y: y_wing_top, w: x_depth_w, h: h_wing, type: 'panel' },// Right Depth
                        { x: x4, y: y_wing_top, w: x_tuck_w, h: h_wing, type: 'flap' }   // Right Tuck
                    ];

                    const scoreLines = [
                        // Horizontal Scores (Top/Bottom Sequence)
                        { x1: x2, y1: y1, x2: x3, y2: y1, type: 'horizontal' }, // Top Lid Fold
                        { x1: x2, y1: y2, x2: x3, y2: y2, type: 'horizontal' }, // Top Depth Fold (Main Top)
                        { x1: x2, y1: y3, x2: x3, y2: y3, type: 'horizontal' }, // Bottom Depth Fold (Main Bottom)
                        { x1: x2, y1: y4, x2: x3, y2: y4, type: 'horizontal' }, // Bottom Lid Fold

                        // Vertical Scores (Wing Sequence)
                        { x1: x1, y1: y_wing_top, x2: x1, y2: y_wing_bottom, type: 'vertical' }, // Left Tuck Fold
                        { x1: x2, y1: y_wing_top, x2: x2, y2: y_wing_bottom, type: 'vertical' }, // Left Wing Hinge
                        { x1: x3, y1: y_wing_top, x2: x3, y2: y_wing_bottom, type: 'vertical' }, // Right Wing Hinge
                        { x1: x4, y1: y_wing_top, x2: x4, y2: y_wing_bottom, type: 'vertical' }  // Right Tuck Fold
                    ];

                    const slots = [
                        // Corner Cuts: Remove the rectangular areas between the vertical strip and horizontal wings
                        // Top Left: Cuts everything left of x2, and above y_wing_top
                        { x: 0, y: 0, w: x2, h: y_wing_top, type: 'corner_cut' },
                        // Top Right: Cuts everything right of x3, and above y_wing_top
                        { x: x3, y: 0, w: blankWidth - x3, h: y_wing_top, type: 'corner_cut' },
                        // Bottom Left: Cuts everything left of x2, and below y_wing_bottom
                        { x: 0, y: y_wing_bottom, w: x2, h: blankHeight - y_wing_bottom, type: 'corner_cut' },
                        // Bottom Right: Cuts everything right of x3, and below y_wing_bottom
                        { x: x3, y: y_wing_bottom, w: blankWidth - x3, h: blankHeight - y_wing_bottom, type: 'corner_cut' }
                    ];

                    const dxfGlueTabPerimeterPoints = [];

                    return { blankWidth, blankHeight, outsideDimensions, layout, scoreLines, slots, dxfGlueTabPerimeterPoints };
                }
            }
        }; 

        const getCleanedLineSegments = (line, cutRects, glueTabInternalPoints) => {
            const xTolerance = 1e-6;
            const isVertical = line.type.startsWith('vertical');
            const isGlueTabScoreLine = line.type === 'vertical_glue_tab';
            let segments = [{ start: isVertical ? line.y1 : line.x1, end: isVertical ? line.y2 : line.x2 }];
            const clipSegments = (currentSegments, clipArea) => {
                let nextSegments = [];
                currentSegments.forEach(seg => {
                    const overlapStart = Math.max(seg.start, clipArea.start);
                    const overlapEnd = Math.min(seg.end, clipArea.end);
                    if (overlapStart < overlapEnd - xTolerance) {
                        if (seg.start < overlapStart - xTolerance) { nextSegments.push({ start: seg.start, end: overlapStart }); }
                        if (seg.end > overlapEnd + xTolerance) { nextSegments.push({ start: overlapEnd, end: seg.end }); }
                    } else { nextSegments.push(seg); }
                });
                return nextSegments;
            };
            cutRects.forEach(rect => {
                let clipArea;
                if (isVertical && line.x1 >= rect.x - xTolerance && line.x1 <= rect.x + rect.w + xTolerance) {
                    clipArea = { start: rect.y, end: rect.y + rect.h };
                    segments = clipSegments(segments, clipArea);
                } else if (!isVertical && line.y1 >= rect.y - xTolerance && line.y1 <= rect.y + rect.h + xTolerance) {
                    clipArea = { start: rect.x, end: rect.x + rect.w };
                    segments = clipSegments(segments, clipArea);
                }
            });
            if (!isGlueTabScoreLine && glueTabInternalPoints.length === 4) {
                const polyP1 = glueTabInternalPoints[0]; const polyP2 = glueTabInternalPoints[1]; const polyP3 = glueTabInternalPoints[2]; const polyP4 = glueTabInternalPoints[3];
                if (isVertical) {
                    if (line.x1 > polyP1.x - xTolerance) {
                        const slopeTop = (polyP2.y - polyP1.y) / (polyP2.x - polyP1.x);
                        const yGlueTabTop = polyP1.y + slopeTop * (line.x1 - polyP1.x);
                        const slopeBottom = (polyP3.y - polyP4.y) / (polyP3.x - polyP4.x);
                        const yGlueTabBottom = polyP4.y + slopeBottom * (line.x1 - polyP4.x);
                        const clipArea = { start: Math.min(yGlueTabTop, yGlueTabBottom), end: Math.max(yGlueTabTop, yGlueTabBottom) };
                        segments = clipSegments(segments, clipArea);
                    }
                } else {
                    const clipArea = { start: polyP1.x, end: line.x2 };
                    segments = clipSegments(segments, clipArea);
                }
            }
            return segments.map(seg => {
                if (isVertical) { return { x1: line.x1, y1: seg.start, x2: line.x1, y2: seg.end }; }
                else { return { x1: seg.start, y1: line.y1, x2: seg.end, y2: line.y1 }; }
            }).filter(l => (Math.abs(l.x1 - l.x2) > xTolerance || Math.abs(l.y1 - l.y2) > xTolerance));
        };

        const generateDxfContent = (blankData, fefcoStyle, L_in, W_in, H_in) => {
            let dxf = `0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1009\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n`;
            const xTolerance = 1e-6;
            const addLine = (color, x1, y1, x2, y2) => {
                if (Math.abs(x1 - x2) > xTolerance || Math.abs(y1 - y2) > xTolerance) {
                    dxf += `0\nLINE\n8\n0\n62\n${color}\n10\n${x1.toFixed(6)}\n20\n${(blankData.blankHeight - y1).toFixed(6)}\n30\n0\n11\n${x2.toFixed(6)}\n21\n${(blankData.blankHeight - y2).toFixed(6)}\n31\n0\n`;
                }
            };
            const y_top_edge = 0; const y_bottom_edge = blankData.blankHeight; const x_left_edge = 0; const x_right_edge = blankData.blankWidth;
            const x_inner_glue_tab = blankData.dxfGlueTabPerimeterPoints.length > 0 ? blankData.dxfGlueTabPerimeterPoints[0].x : blankData.blankWidth;
            const dxfGlueTabPerimeterPoints = blankData.dxfGlueTabPerimeterPoints || [];
            const glueTabStyles = ['0201', '0203', '0200_HSC', '0501'];
            const isGlueTabStyle = glueTabStyles.includes(fefcoStyle);
            if (isGlueTabStyle && dxfGlueTabPerimeterPoints.length === 4) {
                const p1 = dxfGlueTabPerimeterPoints[0]; const p2 = dxfGlueTabPerimeterPoints[1]; const p3 = dxfGlueTabPerimeterPoints[2]; const p4 = dxfGlueTabPerimeterPoints[3];
                addLine(1, p1.x, p1.y, p2.x, p2.y); addLine(1, p2.x, p2.y, p3.x, p3.y); addLine(1, p3.x, p3.y, p4.x, p4.y);
            }

            const topSlots = blankData.slots.filter(s => Math.abs(s.y - y_top_edge) < xTolerance).sort((a, b) => a.x - b.x);
            let lastX_top = 0;
            topSlots.forEach(slot => { if (slot.x > lastX_top + xTolerance) addLine(1, lastX_top, y_top_edge, slot.x, y_top_edge); lastX_top = slot.x + slot.w; });
            const topXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
            if (lastX_top < topXLimit - xTolerance) addLine(1, lastX_top, y_top_edge, topXLimit, y_top_edge);
            
            const bottomSlots = blankData.slots.filter(s => Math.abs(s.y + s.h - y_bottom_edge) < xTolerance).sort((a, b) => a.x - b.x);
            let lastX_bottom = 0;
            bottomSlots.forEach(slot => { if (slot.x > lastX_bottom + xTolerance) addLine(1, lastX_bottom, y_bottom_edge, slot.x, y_bottom_edge); lastX_bottom = slot.x + slot.w; });
            const bottomXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
            if (lastX_bottom < bottomXLimit - xTolerance) addLine(1, lastX_bottom, y_bottom_edge, bottomXLimit, y_bottom_edge);
            
            const leftSlots = blankData.slots.filter(s => Math.abs(s.x - x_left_edge) < xTolerance).sort((a, b) => a.y - b.y);
            let lastY_left = 0;
            leftSlots.forEach(slot => { if (slot.y > lastY_left + xTolerance) addLine(1, x_left_edge, lastY_left, x_left_edge, slot.y); lastY_left = slot.y + slot.h; });
            if (lastY_left < y_bottom_edge - xTolerance) addLine(1, x_left_edge, lastY_left, x_left_edge, y_bottom_edge);
            
            if (!isGlueTabStyle) {
                const rightSlots = blankData.slots.filter(s => Math.abs(s.x + s.w - x_right_edge) < xTolerance).sort((a, b) => a.y - b.y);
                let lastY_right = 0;
                rightSlots.forEach(slot => { if (slot.y > lastY_right + xTolerance) addLine(1, x_right_edge, lastY_right, x_right_edge, slot.y); lastY_right = slot.y + slot.h; });
                if (lastY_right < y_bottom_edge - xTolerance) addLine(1, x_right_edge, lastY_right, x_right_edge, y_bottom_edge);
            }

            blankData.slots.forEach(slot => {
                if (slot.type === 'full') { addLine(1, slot.x, slot.y, slot.x, slot.y + slot.h); addLine(1, slot.x + slot.w, slot.y, slot.x + slot.w, slot.y + slot.h); const hLineY = Math.abs(slot.y - y_top_edge) < xTolerance ? slot.y + slot.h : slot.y; addLine(1, slot.x, hLineY, slot.x + slot.w, hLineY); }
                else if (slot.type === 'half_right_open') { addLine(1, slot.x, slot.y, slot.x, slot.y + slot.h); const hLineY = Math.abs(slot.y - y_top_edge) < xTolerance ? slot.y + slot.h : slot.y; addLine(1, slot.x, hLineY, x_inner_glue_tab, hLineY); }
                else if (slot.type === 'corner_cut') {
                    if (Math.abs(slot.x - x_left_edge) > xTolerance) addLine(1, slot.x, slot.y, slot.x, slot.y + slot.h);
                    if (Math.abs(slot.x + slot.w - x_right_edge) > xTolerance) addLine(1, slot.x + slot.w, slot.y, slot.x + slot.w, slot.y + slot.h);
                    if (Math.abs(slot.y - y_top_edge) > xTolerance) addLine(1, slot.x, slot.y, slot.x + slot.w, slot.y);
                    if (Math.abs(slot.y + slot.h - y_bottom_edge) > xTolerance) addLine(1, slot.x, slot.y + slot.h, slot.x + slot.w, slot.y + slot.h);
                }
            });

            const cutRects = blankData.slots.map(s => s.type !== 'line_cut' ? { x: s.x, y: s.y, w: s.w, h: s.h } : null).filter(Boolean);
            const glueTabInternalPoints = blankData.layout.find(p => p.type === 'polygon_cut')?.points || [];
            blankData.scoreLines.forEach(line => {
                const cleanedSegments = getCleanedLineSegments(line, cutRects, glueTabInternalPoints);
                cleanedSegments.forEach(seg => { addLine(3, seg.x1, seg.y1, seg.x2, seg.y2); });
            });
            dxf += `0\nENDSEC\n0\nEOF`;
            return dxf;
        };

        const generatePdf = (blankData, fefcoStyle, L_in, W_in, H_in, unit, setMessage) => {
            const { jsPDF } = window.jspdf;
            const pdfUnit = 'in';
            const margin = 0.5;
            const pdfPageWidth = blankData.blankWidth + (2 * margin);
            const pdfPageHeight = blankData.blankHeight + (2 * margin);
            const doc = new jsPDF({ orientation: pdfPageWidth > pdfPageHeight ? 'landscape' : 'portrait', unit: pdfUnit, format: [pdfPageWidth, pdfPageHeight] });
            const xTolerance = 1e-6;
            const addLineToPdf = (x1, y1, x2, y2) => { doc.line(x1 + margin, y1 + margin, x2 + margin, y2 + margin); };
            
            doc.setTextColor(0, 0, 0); doc.setFontSize(10);
            doc.text(`FEFCO ${fefcoStyle} - L:${L_in.toFixed(3)} W:${W_in.toFixed(3)} H:${H_in.toFixed(3)} (${pdfUnit})`, margin, margin / 2);
            doc.text(`Blank: ${blankData.blankWidth.toFixed(3)} x ${blankData.blankHeight.toFixed(3)} ${pdfUnit}`, margin, margin/2 + 0.2);
            doc.setDrawColor(255, 0, 0); doc.setLineDashPattern([], 0); doc.setLineWidth(0.02);
            
            const y_top_edge = 0; const y_bottom_edge = blankData.blankHeight; const x_left_edge = 0; const x_right_edge = blankData.blankWidth;
            const x_inner_glue_tab = blankData.dxfGlueTabPerimeterPoints.length > 0 ? blankData.dxfGlueTabPerimeterPoints[0].x : blankData.blankWidth;
            const dxfGlueTabPerimeterPoints = blankData.dxfGlueTabPerimeterPoints || [];
            const glueTabStyles = ['0201', '0203', '0200_HSC', '0501'];
            const isGlueTabStyle = glueTabStyles.includes(fefcoStyle);
            
            if (isGlueTabStyle && dxfGlueTabPerimeterPoints.length === 4) {
                const p1 = dxfGlueTabPerimeterPoints[0]; const p2 = dxfGlueTabPerimeterPoints[1]; const p3 = dxfGlueTabPerimeterPoints[2]; const p4 = dxfGlueTabPerimeterPoints[3];
                addLineToPdf(p1.x, p1.y, p2.x, p2.y); addLineToPdf(p2.x, p2.y, p3.x, p3.y); addLineToPdf(p3.x, p3.y, p4.x, p4.y);
            }

            const topSlots = blankData.slots.filter(s => Math.abs(s.y - y_top_edge) < xTolerance).sort((a, b) => a.x - b.x);
            let lastX_top = 0;
            topSlots.forEach(slot => { if (slot.x > lastX_top + xTolerance) addLineToPdf(lastX_top, y_top_edge, slot.x, y_top_edge); lastX_top = slot.x + slot.w; });
            const topXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
            if (lastX_top < topXLimit - xTolerance) addLineToPdf(lastX_top, y_top_edge, topXLimit, y_top_edge);
            
            const bottomSlots = blankData.slots.filter(s => Math.abs(s.y + s.h - y_bottom_edge) < xTolerance).sort((a, b) => a.x - b.x);
            let lastX_bottom = 0;
            bottomSlots.forEach(slot => { if (slot.x > lastX_bottom + xTolerance) addLineToPdf(lastX_bottom, y_bottom_edge, slot.x, y_bottom_edge); lastX_bottom = slot.x + slot.w; });
            const bottomXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
            if (lastX_bottom < bottomXLimit - xTolerance) addLineToPdf(lastX_bottom, y_bottom_edge, bottomXLimit, y_bottom_edge);
            
            const leftSlots = blankData.slots.filter(s => Math.abs(s.x - x_left_edge) < xTolerance).sort((a, b) => a.y - b.y);
            let lastY_left = 0;
            leftSlots.forEach(slot => { if (slot.y > lastY_left + xTolerance) addLineToPdf(x_left_edge, lastY_left, x_left_edge, slot.y); lastY_left = slot.y + slot.h; });
            if (lastY_left < y_bottom_edge - xTolerance) addLineToPdf(x_left_edge, lastY_left, x_left_edge, y_bottom_edge);
            
            if (!isGlueTabStyle) {
                const rightSlots = blankData.slots.filter(s => Math.abs(s.x + s.w - x_right_edge) < xTolerance).sort((a, b) => a.y - b.y);
                let lastY_right = 0;
                rightSlots.forEach(slot => { if (slot.y > lastY_right + xTolerance) addLineToPdf(x_right_edge, lastY_right, x_right_edge, slot.y); lastY_right = slot.y + slot.h; });
                if (lastY_right < y_bottom_edge - xTolerance) addLineToPdf(x_right_edge, lastY_right, x_right_edge, y_bottom_edge);
            }

            blankData.slots.forEach(slot => {
                if (slot.type === 'full') { 
                    addLineToPdf(slot.x, slot.y, slot.x, slot.y + slot.h); 
                    addLineToPdf(slot.x + slot.w, slot.y, slot.x + slot.w, slot.y + slot.h); 
                    const hLineY = Math.abs(slot.y - y_top_edge) < xTolerance ? slot.y + slot.h : slot.y; 
                    addLineToPdf(slot.x, hLineY, slot.x + slot.w, hLineY); 
                }
                else if (slot.type === 'half_right_open') { 
                    addLineToPdf(slot.x, slot.y, slot.x, slot.y + slot.h); 
                    const hLineY = Math.abs(slot.y - y_top_edge) < xTolerance ? slot.y + slot.h : slot.y; 
                    addLineToPdf(slot.x, hLineY, x_inner_glue_tab, hLineY); 
                }
                else if (slot.type === 'corner_cut') {
                    if (Math.abs(slot.x - x_left_edge) > xTolerance) addLineToPdf(slot.x, slot.y, slot.x, slot.y + slot.h);
                    if (Math.abs(slot.x + slot.w - x_right_edge) > xTolerance) addLineToPdf(slot.x + slot.w, slot.y, slot.x + slot.w, slot.y + slot.h);
                    if (Math.abs(slot.y - y_top_edge) > xTolerance) addLineToPdf(slot.x, slot.y, slot.x + slot.w, slot.y);
                    if (Math.abs(slot.y + slot.h - y_bottom_edge) > xTolerance) addLineToPdf(slot.x, slot.y + slot.h, slot.x + slot.w, slot.y + slot.h);
                }
            });

            doc.setDrawColor(0, 177, 64); doc.setLineDashPattern([0.08, 0.04], 0); doc.setLineWidth(0.02);
            const cutRects = blankData.slots.map(s => s.type !== 'line_cut' ? { x: s.x, y: s.y, w: s.w, h: s.h } : null).filter(Boolean);
            const glueTabInternalPoints = blankData.layout.find(p => p.type === 'polygon_cut')?.points || [];
            blankData.scoreLines.forEach(line => {
                const cleanedSegments = getCleanedLineSegments(line, cutRects, glueTabInternalPoints);
                cleanedSegments.forEach(seg => { addLineToPdf(seg.x1, seg.y1, seg.x2, seg.y2); });
            });
            doc.save(`FEFCO_${fefcoStyle}_${L_in.toFixed(2)}x${W_in.toFixed(2)}x${H_in.toFixed(2)}.pdf`);
            setMessage('PDF file downloaded successfully!');
        };
        
        const drawBlank = (blank, canvas, ctx) => {
            if (!ctx || !blank) return;
            const parentWidth = canvas.parentElement.clientWidth;
            const scale = parentWidth > 0 ? parentWidth / (blank.blankWidth + 1) : 0;
            if (scale === 0) return;
            canvas.width = (blank.blankWidth + 1) * scale;
            canvas.height = (blank.blankHeight + 1) * scale;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const padding = 0.5 * scale;
            ctx.translate(padding, padding);
            ctx.scale(scale, scale);
            
            const x_left_edge = 0;
            const x_right_edge = blank.blankWidth;
            const y_top_edge = 0;
            const y_bottom_edge = blank.blankHeight;
            const xTolerance = 1e-6;

            blank.layout.forEach(part => {
                if (part.type === 'panel' || part.type === 'flap') {
                    ctx.fillStyle = part.type === 'panel' ? '#D4EDDA' : '#C3E6CB';
                    ctx.fillRect(part.x, part.y, part.w, part.h);
                    ctx.strokeStyle = '#666'; ctx.lineWidth = 1 / scale;
                    ctx.strokeRect(part.x, part.y, part.w, part.h);
                } else if (part.type === 'polygon_cut' && part.points) {
                    ctx.fillStyle = '#B8DAFF'; ctx.beginPath();
                    ctx.moveTo(part.points[0].x, part.points[0].y);
                    for (let i = 1; i < part.points.length; i++) { ctx.lineTo(part.points[i].x, part.points[i].y); }
                    ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1 / scale; ctx.stroke();
                }
            });
            ctx.strokeStyle = '#00FF00'; ctx.lineWidth = 1 / scale;
            ctx.setLineDash([5 / scale, 5 / scale]);
            blank.scoreLines.forEach(line => {
                const cutRects = blank.slots.map(s => s.type !== 'line_cut' ? { x: s.x, y: s.y, w: s.w, h: s.h } : null).filter(Boolean);
                const glueTabInternalPoints = blank.layout.find(p => p.type === 'polygon_cut')?.points || [];
                const cleanedSegments = getCleanedLineSegments(line, cutRects, glueTabInternalPoints);
                cleanedSegments.forEach(seg => {
                    ctx.beginPath(); ctx.moveTo(seg.x1, seg.y1); ctx.lineTo(seg.x2, seg.y2); ctx.stroke();
                });
            });
            ctx.setLineDash([]);
            const x_inner_glue_tab_canvas = blank.dxfGlueTabPerimeterPoints.length > 0 ? blank.dxfGlueTabPerimeterPoints[0].x : 0;
            ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 1 / scale;
            blank.slots.forEach(slot => {
                ctx.beginPath();
                if (slot.type === 'full' || slot.type === 'half_right_open') {
                    ctx.moveTo(slot.x, slot.y); ctx.lineTo(slot.x, slot.y + slot.h);
                    if (slot.type !== 'half_right_open') {
                        ctx.moveTo(slot.x + slot.w, slot.y); ctx.lineTo(slot.x + slot.w, slot.y + slot.h);
                    }
                    const hLineY = Math.abs(slot.y) < 1e-6 ? slot.y + slot.h : slot.y;
                    const hLineX2 = slot.type === 'half_right_open' ? x_inner_glue_tab_canvas : slot.x + slot.w;
                    ctx.moveTo(slot.x, hLineY); ctx.lineTo(hLineX2, hLineY);
                } else if (slot.type === 'corner_cut') {
                     if (Math.abs(slot.x - x_left_edge) > xTolerance) { ctx.moveTo(slot.x, slot.y); ctx.lineTo(slot.x, slot.y + slot.h); }
                     if (Math.abs(slot.x + slot.w - x_right_edge) > xTolerance) { ctx.moveTo(slot.x + slot.w, slot.y); ctx.lineTo(slot.x + slot.w, slot.y + slot.h); }
                     if (Math.abs(slot.y - y_top_edge) > xTolerance) { ctx.moveTo(slot.x, slot.y); ctx.lineTo(slot.x + slot.w, slot.y); }
                     if (Math.abs(slot.y + slot.h - y_bottom_edge) > xTolerance) { ctx.moveTo(slot.x, slot.y + slot.h); ctx.lineTo(slot.x + slot.w, slot.y + slot.h); }
                }
                ctx.stroke();
            });
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        };

        // --- Main React Application Component (Re-architected for Stability) ---
        const FEFCOCADApp = () => {
            const [appState, setAppState] = useState({
                length: 12, width: 12, height: 12, // MODIFIED: Default to a common size
                boardProfile: '32 ECT C', fefcoStyle: '0201', // MODIFIED: Default to most common board/style
                priceMsf: 58, outerLiner: 35, innerLiner: 35,
                medium1: 23, middleLiner: 0, medium2: 0,
                flute1: '1.42', flute2: '1.32',
                margin: 0, printUpcharge: 0.00, setupFee: 0, quantity: 1000,
                // NEW
                topTenSelection: '12 x 12 x 12 (S-4125)',
            });

            const [results, setResults] = useState({
                blankDimensions: null, outsideDimensions: null,
                squareFootage: null, wastePercentage: null, inchesOfRule: null, // MODIFIED
                quoteResults: null, message: 'Enter dimensions or select a preset to begin.',
            });

            const canvasRef = useRef(null);

            // --- START KIWIPLAN EXPORT FUNCTION ---
            const exportToKiwiplan = () => {
                // Map appState to the expected format
                const boxData = {
                    sku: appState.topTenSelection !== 'custom' ? appState.topTenSelection : `CUSTOM-${appState.length}x${appState.width}x${appState.height}`,
                    style: appState.fefcoStyle,
                    L: parseFloat(appState.length),
                    W: parseFloat(appState.width),
                    D: parseFloat(appState.height),
                    quantity: parseInt(appState.quantity),
                    grade: appState.boardProfile,
                    flute: appState.flute1 // Simplifying to primary flute for the CSV
                };

                // Standard Kiwiplan KMC Order Ingestion Layout
                const headers = ["RecordType","Customer","OrderNo","ItemCode","Style","L","W","D","Qty","Due"];
                
                // Convert to Metric (Kiwiplan native)
                const L_mm = Math.round(boxData.L * 25.4);
                const W_mm = Math.round(boxData.W * 25.4);
                const D_mm = Math.round(boxData.D * 25.4);

                const row = [
                    "ORD",
                    "TEMP", // Placeholder for Cust ID
                    `JOB-${Date.now()}`,
                    boxData.sku || "NEW-ITEM",
                    boxData.style,
                    L_mm, W_mm, D_mm,
                    boxData.quantity,
                    new Date().toISOString().slice(0,10).replace(/-/g,"")
                ];

                const csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n" + row.join(",");
                
                const link = document.createElement("a");
                link.setAttribute("href", encodeURI(csvContent));
                link.setAttribute("download", `Kiwiplan_Load_${boxData.sku.replace(/[^a-z0-9]/gi, '_')}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };
            // --- END KIWIPLAN EXPORT FUNCTION ---

            const handleStateChange = useCallback((changes) => {
                setAppState(prevState => {
                    let newState = { ...prevState, ...changes };

                    // NEW: Handle Top Ten SKU selection
                    if ('topTenSelection' in changes) {
                        const selectedSkuName = changes.topTenSelection;
                        if (selectedSkuName === "custom") {
                           newState.topTenSelection = "custom";
                        } else {
                            const selectedSku = topTenSkus.find(s => s.name === selectedSkuName);
                            if (selectedSku) {
                                newState.length = selectedSku.l;
                                newState.width = selectedSku.w;
                                newState.height = selectedSku.h;
                            }
                        }
                    }
                    
                    // If any dimension is changed manually, set the SKU dropdown to "custom"
                    if (['length', 'width', 'height'].some(key => key in changes)) {
                        newState.topTenSelection = "custom";
                    }

                    if ('boardProfile' in changes) {
                        const newBoardProfile = changes.boardProfile;
                        const board = boardData[newBoardProfile];
                        if (board) {
                            const comps = board.components;
                            const derivedChanges = {
                                outerLiner: comps.outerLiner || 0,
                                innerLiner: comps.innerLiner || 0,
                                medium1: comps.medium1 || 0,
                                middleLiner: comps.middleLiner || 0,
                                medium2: comps.medium2 || 0,
                                priceMsf: board.priceMsf || 0,
                            };
                            const fluteTakeupFactors = { 'B': '1.32', 'C': '1.42' };
                            if (board.type === 'doublewall' && board.flutes && board.flutes.length === 2) {
                                const factorA = fluteTakeupFactors[board.flutes[0]];
                                const factorB = fluteTakeupFactors[board.flutes[1]];
                                if (parseFloat(factorA) < parseFloat(factorB)) {
                                    derivedChanges.flute1 = factorA;
                                    derivedChanges.flute2 = factorB;
                                } else {
                                    derivedChanges.flute1 = factorB;
                                    derivedChanges.flute2 = factorA;
                                }
                            } else if (board.type === 'singlewall' && board.flute) {
                                derivedChanges.flute1 = fluteTakeupFactors[board.flute];
                                derivedChanges.medium2 = 0;
                                derivedChanges.middleLiner = 0;
                            }
                            newState = { ...newState, ...derivedChanges };
                        }
                    }
                    return newState;
                });
            }, []);

            useEffect(() => {
                const {
                    length, width, height, boardProfile, fefcoStyle,
                    priceMsf, outerLiner, innerLiner, medium1, middleLiner, medium2,
                    flute1, flute2, margin, printUpcharge, setupFee, quantity
                } = appState;

                const L_in = parseFloat(length);
                const W_in = parseFloat(width);
                const H_in = parseFloat(height);

                if (isNaN(L_in) || isNaN(W_in) || isNaN(H_in) || L_in <= 0 || W_in <= 0 || H_in <= 0) {
                    setResults(r => ({ ...r, message: 'Please enter valid positive numbers for all CAD dimensions.', quoteResults: null, blankDimensions: null, wastePercentage: null, inchesOfRule: null }));
                    return;
                }

                const board = boardData[boardProfile];
                const selectedStyle = fefcoStyles[fefcoStyle];

                if (!board || !selectedStyle) {
                    setResults(r => ({ ...r, message: 'Please select a valid style and board profile.', quoteResults: null, blankDimensions: null, wastePercentage: null, inchesOfRule: null }));
                    return;
                }

                const thickness_in = board.thickness;
                const blankData = selectedStyle.calculateBlank(L_in, W_in, H_in, thickness_in);
                const blankAreaSqIn = blankData.blankWidth * blankData.blankHeight;
                const blankAreaSqFt = blankAreaSqIn / 144;

                // MODIFIED: Restored waste calculation
                let waste = 0;
                if (blankAreaSqIn > 0) {
                    let totalWasteAreaSqIn = 0;
                    // Slot waste
                    blankData.slots.forEach(slot => { 
                        if (slot.type !== 'corner_cut') {
                            totalWasteAreaSqIn += slot.w * slot.h; 
                        } else {
                            // For 0401 corner cuts, these are large areas of waste
                            totalWasteAreaSqIn += slot.w * slot.h;
                        }
                    });
                    
                    // Glue flap corner trim waste
                    const glueTabStyles = ['0201', '0203', '0200_HSC'];
                    if(glueTabStyles.includes(fefcoStyle)) {
                        const glueFlap_in = 1.375;
                        let flapLength_for_waste = 0;
                        if (fefcoStyle === '0201' || fefcoStyle === '0200_HSC') {
                           flapLength_for_waste = roundToNearestFraction(W_in / 2, 1/16) + roundToNearestFraction(thickness_in / 2, 1/16);
                        } else if (fefcoStyle === '0203') {
                           flapLength_for_waste = W_in;
                        }
                        const angle15DegRad = 15 * Math.PI / 180;
                        const angleOffset = Math.tan(angle15DegRad) * glueFlap_in;
                        // Waste from the two angled corners is equivalent to a rectangle of size angleOffset * glueFlap_in
                        totalWasteAreaSqIn += angleOffset * glueFlap_in;
                    }
                    waste = (totalWasteAreaSqIn / blankAreaSqIn) * 100;
                }

                // NEW: Inches of Rule Calculation
                let totalRuleInches = 0;
                const cutRects = blankData.slots.map(s => ({ x: s.x, y: s.y, w: s.w, h: s.h }));
                const glueTabInternalPoints = blankData.layout.find(p => p.type === 'polygon_cut')?.points || [];
                // 1. Score lines
                blankData.scoreLines.forEach(line => {
                    const cleanedSegments = getCleanedLineSegments(line, cutRects, glueTabInternalPoints);
                    cleanedSegments.forEach(seg => {
                        totalRuleInches += Math.sqrt(Math.pow(seg.x2 - seg.x1, 2) + Math.pow(seg.y2 - seg.y1, 2));
                    });
                });
                // 2. Cut lines (Perimeter + Slots) from DXF logic
                const xTolerance = 1e-6;
                const y_top_edge = 0; const y_bottom_edge = blankData.blankHeight; const x_left_edge = 0; const x_right_edge = blankData.blankWidth;
                const x_inner_glue_tab = blankData.dxfGlueTabPerimeterPoints.length > 0 ? blankData.dxfGlueTabPerimeterPoints[0].x : blankData.blankWidth;
                const dxfGlueTabPerimeterPoints = blankData.dxfGlueTabPerimeterPoints || [];
                const glueTabStyles = ['0201', '0203', '0200_HSC', '0501'];
                const isGlueTabStyle = glueTabStyles.includes(fefcoStyle);
                if (isGlueTabStyle && dxfGlueTabPerimeterPoints.length === 4) {
                    for(let i = 0; i < 4; i++) {
                        const p1 = dxfGlueTabPerimeterPoints[i];
                        const p2 = dxfGlueTabPerimeterPoints[(i + 1) % 4];
                        totalRuleInches += Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    }
                }
                const topSlots = blankData.slots.filter(s => Math.abs(s.y - y_top_edge) < xTolerance && s.type !== 'corner_cut').sort((a, b) => a.x - b.x);
                let lastX_top = 0;
                topSlots.forEach(slot => { if (slot.x > lastX_top + xTolerance) totalRuleInches += (slot.x - lastX_top); lastX_top = slot.x + slot.w; });
                const topXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
                if (lastX_top < topXLimit - xTolerance) totalRuleInches += (topXLimit - lastX_top);
                const bottomSlots = blankData.slots.filter(s => Math.abs(s.y + s.h - y_bottom_edge) < xTolerance && s.type !== 'corner_cut').sort((a, b) => a.x - b.x);
                let lastX_bottom = 0;
                bottomSlots.forEach(slot => { if (slot.x > lastX_bottom + xTolerance) totalRuleInches += (slot.x - lastX_bottom); lastX_bottom = slot.x + slot.w; });
                const bottomXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
                if (lastX_bottom < bottomXLimit - xTolerance) totalRuleInches += (bottomXLimit - lastX_bottom);
                const leftSlots = blankData.slots.filter(s => Math.abs(s.x - x_left_edge) < xTolerance && s.type !== 'corner_cut').sort((a, b) => a.y - b.y);
                let lastY_left = 0;
                leftSlots.forEach(slot => { if (slot.y > lastY_left + xTolerance) totalRuleInches += (slot.y - lastY_left); lastY_left = slot.y + slot.h; });
                if (lastY_left < y_bottom_edge - xTolerance) totalRuleInches += (y_bottom_edge - lastY_left);
                if (!isGlueTabStyle) {
                    const rightSlots = blankData.slots.filter(s => Math.abs(s.x + s.w - x_right_edge) < xTolerance && s.type !== 'corner_cut').sort((a, b) => a.y - b.y);
                    let lastY_right = 0;
                    rightSlots.forEach(slot => { if (slot.y > lastY_right + xTolerance) totalRuleInches += (slot.y - lastY_right); lastY_right = slot.y + slot.h; });
                    if (lastY_right < y_bottom_edge - xTolerance) totalRuleInches += (y_bottom_edge - lastY_right);
                }
                blankData.slots.forEach(slot => {
                    if (slot.type !== 'corner_cut') {
                        totalRuleInches += slot.h; // Left vertical
                        if (slot.type === 'full') { totalRuleInches += slot.h; } // Right vertical
                        totalRuleInches += slot.w; // Inner horizontal
                    } else {
                         // Corner cut rule is the interior boundary of the cut
                         totalRuleInches += slot.w + slot.h;
                    }
                });

                const pricingInputs = {
                    outerLiner: parseFloat(outerLiner) || 0, innerLiner: parseFloat(innerLiner) || 0,
                    middleLiner: parseFloat(middleLiner) || 0, medium1: parseFloat(medium1) || 0,
                    medium2: parseFloat(medium2) || 0, takeUpFactor1: parseFloat(flute1) || 0,
                    takeUpFactor2: board.type === 'doublewall' ? (parseFloat(flute2) || 0) : 0,
                    priceMsf: parseFloat(priceMsf) || 0, blankAreaSqFt: blankAreaSqFt,
                    quantity: parseInt(quantity) || 0, marginPercent: parseFloat(margin) || 0,
                    printUpcharge: parseFloat(printUpcharge) || 0, setupFee: parseFloat(setupFee) || 0,
                };

                const quote = estimatingEngine.calculate(pricingInputs);

                setResults({
                    blankDimensions: blankData, outsideDimensions: blankData.outsideDimensions,
                    squareFootage: blankAreaSqFt, wastePercentage: waste, inchesOfRule: totalRuleInches,
                    quoteResults: quote, message: `Generated blank for FEFCO ${fefcoStyle}: ${selectedStyle.name}`
                });

            }, [appState]);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas ? canvas.getContext('2d') : null;
                if (ctx && results.blankDimensions) {
                    drawBlank(results.blankDimensions, canvas, ctx);
                } else if (ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }, [results.blankDimensions]);

            const handleDownload = (type) => {
                const { blankDimensions } = results;
                const { length, width, height, fefcoStyle } = appState;
                const L_in = parseFloat(length);
                const W_in = parseFloat(width);
                const H_in = parseFloat(height);

                if (!blankDimensions || isNaN(L_in) || isNaN(W_in) || isNaN(H_in)) {
                    setResults(prev => ({...prev, message: 'Cannot generate file. Please check input dimensions.'}));
                    return;
                }

                if (type === 'dxf') {
                    const dxfContent = generateDxfContent(blankDimensions, fefcoStyle, L_in, W_in, H_in);
                    const blob = new Blob([dxfContent], { type: 'application/dxf' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `FEFCO_${fefcoStyle}_${L_in.toFixed(2)}x${W_in.toFixed(2)}x${H_in.toFixed(2)}.dxf`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    setResults(prev => ({...prev, message: 'DXF file downloaded successfully!'}));
                } else if (type === 'pdf') {
                    generatePdf(blankDimensions, fefcoStyle, L_in, W_in, H_in, 'in', (msg) => setResults(prev => ({...prev, message: msg})));
                }
            };
            const { blankDimensions, outsideDimensions, squareFootage, wastePercentage, quoteResults, message, inchesOfRule } = results;

            return (
                <div className="max-w-7xl mx-auto p-4 md:p-8">
                    <div className="text-center mb-8">
                         <h1 className="text-4xl md:text-5xl font-extrabold text-slate-800 flex items-baseline justify-center">
                            <span>corru</span><span className="text-orange-500 text-5xl md:text-6xl font-normal mx-1" style={{ transform: 'translateY(2px)' }}>~</span><span className="font-black">CAD</span>
                        </h1>
                        <p className="text-md text-gray-600">v1.7 - Precision Engine with Presets</p>
                    </div>
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                        <div className="lg:col-span-2 bg-white p-6 rounded-lg shadow-sm space-y-6">
                            <div>
                                <h2 className="section-title">CAD Inputs</h2>
                                {/* NEW: Top Ten SKU Selector */}
                                <div className="mb-4">
                                     <label className="block text-sm font-medium text-gray-700">Top 10 SKU Presets</label>
                                     <select value={appState.topTenSelection} onChange={e => handleStateChange({ topTenSelection: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md bg-yellow-50">
                                          <option value="custom">-- Custom Dimensions --</option>
                                          {topTenSkus.map(sku => <option key={sku.name} value={sku.name}>{sku.name}</option>)}
                                     </select>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700">Length (L) (in)</label>
                                        <input type="number" value={appState.length} onChange={e => handleStateChange({ length: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700">Width (W) (in)</label>
                                        <input type="number" value={appState.width} onChange={e => handleStateChange({ width: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700">Height (H) (in)</label>
                                        <input type="number" value={appState.height} onChange={e => handleStateChange({ height: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                    </div>
                                    <div className="md:col-span-2">
                                        <label className="block text-sm font-medium text-gray-700">FEFCO Style</label>
                                        <select value={appState.fefcoStyle} onChange={e => handleStateChange({ fefcoStyle: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md">
                                            {Object.keys(fefcoStyles).sort().map(style => <option key={style} value={style}>{style} - {fefcoStyles[style].name}</option>)}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700">Board</label>
                                        <select value={appState.boardProfile} onChange={e => handleStateChange({ boardProfile: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md">
                                            {Object.keys(boardData).map(profile => <option key={profile} value={profile}>{profile}</option>)}
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <div>
                                <h2 className="section-title">Precision Estimating Inputs</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div className="space-y-4 p-4 border rounded-md bg-gray-50">
                                            <h3 className="font-semibold text-gray-700">Material Definition</h3>
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700">Market Price ($/msf)</label>
                                                <input type="number" value={appState.priceMsf} onChange={e => handleStateChange({ priceMsf: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Outer Liner</label>
                                                    <input type="number" value={appState.outerLiner} onChange={e => handleStateChange({ outerLiner: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Inner Liner</label>
                                                    <input type="number" value={appState.innerLiner} onChange={e => handleStateChange({ innerLiner: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Medium 1</label>
                                                    <input type="number" value={appState.medium1} onChange={e => handleStateChange({ medium1: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">Flute 1</label>
                                                    <select value={appState.flute1} onChange={e => handleStateChange({ flute1: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md">
                                                        <option value="1.42">C Flute</option>
                                                        <option value="1.32">B Flute</option>
                                                    </select>
                                                </div>
                                                {boardData[appState.boardProfile]?.type === 'doublewall' && (
                                                    <>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">Middle Liner</label>
                                                            <input type="number" value={appState.middleLiner} onChange={e => handleStateChange({ middleLiner: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">Medium 2</label>
                                                            <input type="number" value={appState.medium2} onChange={e => handleStateChange({ medium2: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                                        </div>
                                                         <div>
                                                            <label className="block text-sm font-medium text-gray-700">Flute 2</label>
                                                            <select value={appState.flute2} onChange={e => handleStateChange({ flute2: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md">
                                                                <option value="1.42">C Flute</option>
                                                                <option value="1.32">B Flute</option>
                                                            </select>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                    </div>
                                    <div className="space-y-4 p-4 border rounded-md bg-gray-50">
                                            <h3 className="font-semibold text-gray-700">Quote Details</h3>
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700">Margin (%)</label>
                                                <input type="number" value={appState.margin} onChange={e => handleStateChange({ margin: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700">Printing ($/box)</label>
                                                <input type="number" step="0.01" value={appState.printUpcharge} onChange={e => handleStateChange({ printUpcharge: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700">Setup Fee ($)</label>
                                                <input type="number" value={appState.setupFee} onChange={e => handleStateChange({ setupFee: e.target.value })} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                            </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div className="bg-white p-6 rounded-lg shadow-sm space-y-6">
                            <h2 className="section-title">Quote Summary</h2>
                            {message && <div className="text-sm p-3 rounded-md bg-blue-50 text-blue-700">{message}</div>}
                            <div className="bg-gray-50 p-4 rounded-md">
                                <h3 className="font-semibold text-gray-700 mb-2">CAD Output</h3>
                                {blankDimensions && outsideDimensions ? (
                                    <div className="bg-white p-4 rounded-md shadow-inner text-sm space-y-1 mb-4">
                                            <h3 className="font-semibold text-gray-800 mb-2">Calculated Dimensions:</h3>
                                            <div className="grid grid-cols-2 gap-x-4">
                                                <span>Internal L:</span><span className="font-medium text-right">{parseFloat(appState.length).toFixed(3)} in</span>
                                                <span>Internal W:</span><span className="font-medium text-right">{parseFloat(appState.width).toFixed(3)} in</span>
                                                <span>Internal H:</span><span className="font-medium text-right">{parseFloat(appState.height).toFixed(3)} in</span>
                                            </div>
                                            <div className="border-t my-2"></div>
                                            <div className="grid grid-cols-2 gap-x-4">
                                                <span>Outside L:</span><span className="font-medium text-right">{outsideDimensions.length.toFixed(3)} in</span>
                                                <span>Outside W:</span><span className="font-medium text-right">{outsideDimensions.width.toFixed(3)} in</span>
                                                <span>Outside H:</span><span className="font-medium text-right">{outsideDimensions.height.toFixed(3)} in</span>
                                            </div>
                                            <div className="border-t my-2"></div>
                                            <div className="grid grid-cols-2 gap-x-4">
                                                <span>Blank W:</span><span className="font-medium text-right">{blankDimensions.blankWidth.toFixed(3)} in</span>
                                                <span>Blank H:</span><span className="font-medium text-right">{blankDimensions.blankHeight.toFixed(3)} in</span>
                                            </div>
                                            <div className="border-t my-2"></div>
                                            <div className="grid grid-cols-2 gap-x-4 text-base">
                                                <span className="font-bold">Sq. Footage:</span><span className="font-bold text-right">{squareFootage ? squareFootage.toFixed(4) : 'N/A'} ft</span>
                                                {/* MODIFIED: Display restored values */}
                                                <span className="font-bold">Inches of Rule:</span><span className="font-bold text-right">{inchesOfRule ? inchesOfRule.toFixed(2) : 'N/A'} in</span>
                                                <span className="font-bold">Est. Waste:</span><span className="font-bold text-right">{wastePercentage ? wastePercentage.toFixed(2) : 'N/A'}%</span>
                                            </div>
                                    </div>
                                ) : <div className="text-sm text-gray-500">Enter valid dimensions...</div>}
                                <div className="mt-4 border rounded-md bg-white overflow-hidden">
                                    <canvas ref={canvasRef}></canvas>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
    <button 
        onClick={() => handleDownload('dxf')} 
        disabled={!blankDimensions} 
        className="w-full flex justify-center items-center bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md disabled:bg-gray-400"
    >
        Download DXF
    </button>
    <button 
        onClick={() => handleDownload('pdf')} 
        disabled={!blankDimensions} 
        className="w-full flex justify-center items-center bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md disabled:bg-gray-400"
    >
        Download PDF
    </button>
    <button 
        onClick={exportToKiwiplan} 
        disabled={!blankDimensions} 
        className="w-full flex justify-center items-center bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md disabled:bg-gray-400"
    >
        Export to Kiwiplan (.CSV)
    </button>
</div>
                            </div>
                            <div className="bg-indigo-50 p-4 rounded-md">
                                <h3 className="font-semibold text-indigo-800 mb-2">Pricing Output</h3>
                                {quoteResults ? (
                                    <>
                                            <div className="space-y-2 text-sm text-indigo-900">
                                                <div className="flex justify-between"><span>Material Cost / Box:</span><span className="font-medium">${quoteResults.baseMaterialCost.toFixed(4)}</span></div>
                                                <div className="flex justify-between"><span>Margin / Box:</span><span className="font-medium">${quoteResults.marginAmount.toFixed(4)}</span></div>
                                                <div className="flex justify-between"><span>Printing / Box:</span><span className="font-medium">${parseFloat(appState.printUpcharge).toFixed(4)}</span></div>
                                                <div className="border-t border-indigo-200 my-1"></div>
                                                <div className="flex justify-between font-bold text-base"><span>Cost per Box:</span><span>${quoteResults.costPerBox.toFixed(4)}</span></div>
                                            </div>
                                            <div className="mt-4 text-center">
                                                <label className="block text-sm font-medium text-gray-700 mb-1">Quantity</label>
                                                <input type="number" value={appState.quantity} onChange={e => handleStateChange({ quantity: e.target.value })} className="w-full p-2 rounded-md mb-2 border-gray-300"/>
                                                <div className="bg-white p-3 rounded-md">
                                                    <span className="text-gray-600">Total Cost:</span>
                                                    <span className="final-quote-value text-2xl font-bold ml-2">${quoteResults.totalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                                                </div>
                                            </div>
                                    </>
                                ) : <div className="text-sm text-indigo-700">Enter valid CAD dimensions to calculate a quote.</div>}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => <FEFCOCADApp />;
        const rootElement = document.getElementById('root');
        const root = createRoot(rootElement);
        root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
</body>
</html>
