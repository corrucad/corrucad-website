<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CorruCAD v0.8 (Restored Calculations)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .section-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }
        .final-quote-value {
            color: #4338ca;
        }
        canvas {
            display: block;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
        }
    </style>
</head>

<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const createRoot = ReactDOM.createRoot;

        // --- CorruCAD Precision Estimating Engine v1.0 (from v0.8) ---
        const estimatingEngine = (() => {
            const calculateQuote = (inputs) => {
                const defaults = {
                    outerLiner: 0, innerLiner: 0, medium: 0, takeUpFactor: 0,
                    priceMsf: 0, blankAreaSqFt: 0, quantity: 0, marginPercent: 0,
                    printUpcharge: 0, setupFee: 0
                };
                const data = { ...defaults, ...inputs };
                const mediumWeight = data.medium * data.takeUpFactor;
                const totalFiberWeightLbsMsf = data.outerLiner + data.innerLiner + mediumWeight;
                const totalTonsPerMsf = totalFiberWeightLbsMsf / 2000;
                const pricePerTon = totalTonsPerMsf > 0 ? data.priceMsf / totalTonsPerMsf : 0;
                const boxWeightLbs = (data.blankAreaSqFt / 1000) * totalFiberWeightLbsMsf;
                const boxWeightTons = boxWeightLbs / 2000;
                const baseMaterialCost = boxWeightTons * pricePerTon;
                const marginAmount = baseMaterialCost * (data.marginPercent / 100);
                const finalCostPerBox = baseMaterialCost + marginAmount + data.printUpcharge;
                const totalCost = (finalCostPerBox * data.quantity) + data.setupFee;
                return {
                    pricePerTon: pricePerTon,
                    totalFiberWeightLbsMsf: totalFiberWeightLbsMsf,
                    boxWeightLbs: boxWeightLbs,
                    baseMaterialCost: baseMaterialCost,
                    marginAmount: marginAmount,
                    costPerBox: finalCostPerBox,
                    totalCost: totalCost
                };
            };
            return {
                calculate: calculateQuote
            };
        })();


        // --- Start of STABLE Geometry and Drawing Engine (from v0.5) ---

        // Helper function to round a value to the nearest specified fraction (in inches)
        const roundToNearestFraction = (valueInInches, fraction) => {
            return Math.ceil(valueInInches / fraction) * fraction;
        };
        
        const boardProfiles = {
            '32 ECT B': 1/8, // 0.125 inches
            '32 ECT C': 3/16, // 0.1875 inches
            '44 ECT B': 1/8, // 0.125 inches
            '44 ECT C': 3/16, // 0.1875 inches
            '48 ECT BC': 5/16, // 0.3125 inches
            '55 ECT BC': 5/16, // 0.3125 inches
        };

        // FEFCO data and blank calculation logic
        const fefcoStyles = {
            '0201': { // RSC - Regular Slotted Container
                name: 'Regular Slotted Container (RSC)',
                calculateBlank: (L_input, W_input, H_input, thickness) => {
                    const glueFlap = 1.375; // Standard glue flap in inches
                    const slotWidth_full_in = 3/8; // Common slot width for full slots
                    const slotWidth_half_in = 3/16; // Common slot width for half slots (Panel 4)
                    const oneSixteenth_in = 1/16; // 1/16 inch
                    const angle15DegRad = 15 * Math.PI / 180; // 15 degrees in radians

                    const panel1_width = L_input + thickness - oneSixteenth_in;
                    const panel2_width = W_input + thickness;
                    const panel3_width = L_input + thickness;
                    const panel4_width = W_input + thickness - oneSixteenth_in;

                    const x_inner_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width;
                    const x_outer_glue_tab = x_inner_glue_tab + glueFlap;
                    const x_panel4_end_before_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width;
                    const internalH_for_blank = H_input + (2 * thickness);
                    const halfW = W_input / 2;
                    const halfCal = thickness / 2;
                    const minorFlapLength_inches = roundToNearestFraction(halfW, 1/16) + roundToNearestFraction(halfCal, 1/16);
                    const blankWidth = x_outer_glue_tab;
                    const blankHeight = internalH_for_blank + (2 * minorFlapLength_inches);
                    const angleOffset = Math.tan(angle15DegRad) * glueFlap;
                    const y_top_body_crease = minorFlapLength_inches;
                    const y_bottom_body_crease = internalH_for_blank + minorFlapLength_inches;

                    const glueTabPoints = [ { x: x_inner_glue_tab, y: y_top_body_crease }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_inner_glue_tab, y: y_bottom_body_crease } ];
                    const dxfGlueTabPerimeterPoints = [ { x: x_panel4_end_before_glue_tab, y: y_bottom_body_crease }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_panel4_end_before_glue_tab, y: y_top_body_crease } ];
                    const glueTabScoreLine = { x1: x_inner_glue_tab, y1: y_top_body_crease, x2: x_inner_glue_tab, y2: y_bottom_body_crease };
                    const outsideDimensions = { length: L_input + (2 * thickness), width: W_input + (2 * thickness), height: H_input + (3 * thickness) };
                    
                    const slots = [
                        { x: panel1_width - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' },
                        { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' },
                        { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' },
                        { x: x_inner_glue_tab - slotWidth_half_in, y: 0, w: slotWidth_half_in, h: minorFlapLength_inches, type: 'half_right_open' },
                        { x: panel1_width - (slotWidth_full_in / 2), y: internalH_for_blank + minorFlapLength_inches, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' },
                        { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: internalH_for_blank + minorFlapLength_inches, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' },
                        { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: internalH_for_blank + minorFlapLength_inches, w: slotWidth_full_in, h: minorFlapLength_inches, type: 'full' },
                        { x: x_inner_glue_tab - slotWidth_half_in, y: internalH_for_blank + minorFlapLength_inches, w: slotWidth_half_in, h: minorFlapLength_inches, type: 'half_right_open' },
                    ];

                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: minorFlapLength_inches, w: panel1_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width, y: minorFlapLength_inches, w: panel2_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width, y: minorFlapLength_inches, w: panel3_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width + panel3_width, y: minorFlapLength_inches, w: panel4_width, h: internalH_for_blank, type: 'panel' }, { points: glueTabPoints, type: 'polygon_cut' }, { x: 0, y: 0, w: panel1_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width, y: 0, w: panel2_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: 0, w: panel3_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: 0, w: panel4_width, h: minorFlapLength_inches, type: 'flap' }, { x: 0, y: internalH_for_blank + minorFlapLength_inches, w: panel1_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width, y: internalH_for_blank + minorFlapLength_inches, w: panel2_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: internalH_for_blank + minorFlapLength_inches, w: panel3_width, h: minorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: internalH_for_blank + minorFlapLength_inches, w: panel4_width, h: minorFlapLength_inches, type: 'flap' }, ], scoreLines: [ { x1: panel1_width, y1: 0, x2: panel1_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width, y1: 0, x2: panel1_width + panel2_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width + panel3_width, y1: 0, x2: panel1_width + panel2_width + panel3_width, y2: blankHeight, type: 'vertical' }, { x1: glueTabScoreLine.x1, y1: glueTabScoreLine.y1, x2: glueTabScoreLine.x2, y2: glueTabScoreLine.y2, type: 'vertical_glue_tab' }, { x1: 0, y1: minorFlapLength_inches, x2: blankWidth, y2: minorFlapLength_inches, type: 'horizontal' }, { x1: 0, y1: internalH_for_blank + minorFlapLength_inches, x2: blankWidth, y2: internalH_for_blank + minorFlapLength_inches, type: 'horizontal' }, ], dxfGlueTabPerimeterPoints, slots };
                }
            },
            '0203': { // FOL - Full Overlap Container
                name: 'Full Overlap Container (FOL)',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const glueFlap = 1.375; const slotWidth_full_in = 3/8; const slotWidth_half_in = 3/16; const oneSixteenth_in = 1/16; const angle15DegRad = 15 * Math.PI / 180;
                    const panel1_width = L_in + thickness - oneSixteenth_in; const panel2_width = W_in + thickness; const panel3_width = L_in + thickness; const panel4_width = W_in + thickness - oneSixteenth_in;
                    const x_inner_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width; const x_outer_glue_tab = x_inner_glue_tab + glueFlap; const x_panel4_end_before_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width;
                    const internalH_for_blank = H_in + (3 * thickness);
                    const majorFlapLength_inches = W_in;
                    const blankWidth = x_outer_glue_tab; const blankHeight = internalH_for_blank + (2 * majorFlapLength_inches);
                    const angleOffset = Math.tan(angle15DegRad) * glueFlap;
                    const y_top_body_crease = majorFlapLength_inches; const y_bottom_body_crease = internalH_for_blank + majorFlapLength_inches;
                    const glueTabPoints = [ { x: x_inner_glue_tab, y: y_top_body_crease }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_inner_glue_tab, y: y_bottom_body_crease } ];
                    const dxfGlueTabPerimeterPoints = [ { x: x_panel4_end_before_glue_tab, y: y_bottom_body_crease }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_panel4_end_before_glue_tab, y: y_top_body_crease } ];
                    const glueTabScoreLine = { x1: x_inner_glue_tab, y1: y_top_body_crease, x2: x_inner_glue_tab, y2: y_bottom_body_crease };
                    const outsideDimensions = { length: L_in + (2 * thickness), width: W_in + (2 * thickness), height: H_in + (4 * thickness) };
                    const slots = [ { x: panel1_width - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: 0, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: x_inner_glue_tab - slotWidth_half_in, y: 0, w: slotWidth_half_in, h: majorFlapLength_inches, type: 'half_right_open' }, { x: panel1_width - (slotWidth_full_in / 2), y: internalH_for_blank + majorFlapLength_inches, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: internalH_for_blank + majorFlapLength_inches, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: internalH_for_blank + majorFlapLength_inches, w: slotWidth_full_in, h: majorFlapLength_inches, type: 'full' }, { x: x_inner_glue_tab - slotWidth_half_in, y: internalH_for_blank + majorFlapLength_inches, w: slotWidth_half_in, h: majorFlapLength_inches, type: 'half_right_open' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: majorFlapLength_inches, w: panel1_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width, y: majorFlapLength_inches, w: panel2_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width, y: majorFlapLength_inches, w: panel3_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width + panel3_width, y: majorFlapLength_inches, w: panel4_width, h: internalH_for_blank, type: 'panel' }, { points: glueTabPoints, type: 'polygon_cut' }, { x: 0, y: 0, w: panel1_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width, y: 0, w: panel2_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: 0, w: panel3_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: 0, w: panel4_width, h: majorFlapLength_inches, type: 'flap' }, { x: 0, y: internalH_for_blank + majorFlapLength_inches, w: panel1_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width, y: internalH_for_blank + majorFlapLength_inches, w: panel2_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: internalH_for_blank + majorFlapLength_inches, w: panel3_width, h: majorFlapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: internalH_for_blank + majorFlapLength_inches, w: panel4_width, h: majorFlapLength_inches, type: 'flap' }, ], scoreLines: [ { x1: panel1_width, y1: 0, x2: panel1_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width, y1: 0, x2: panel1_width + panel2_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width + panel3_width, y1: 0, x2: panel1_width + panel2_width + panel3_width, y2: blankHeight, type: 'vertical' }, { x1: glueTabScoreLine.x1, y1: glueTabScoreLine.y1, x2: glueTabScoreLine.x2, y2: glueTabScoreLine.y2, type: 'vertical_glue_tab' }, { x1: 0, y1: majorFlapLength_inches, x2: blankWidth, y2: majorFlapLength_inches, type: 'horizontal' }, { x1: 0, y1: internalH_for_blank + majorFlapLength_inches, x2: blankWidth, y2: internalH_for_blank + majorFlapLength_inches, type: 'horizontal' }, ], dxfGlueTabPerimeterPoints, slots };
                }
            },
             '0200_HSC': { // HSC - Half-Slotted Container
                name: 'Half-Slotted Container (HSC)',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const glueFlap_in = 1.375; const slotWidth_full_in = 3/8; const slotWidth_half_in = 3/16; const oneSixteenth_in = 1/16; const angle15DegRad = 15 * Math.PI / 180;
                    const panel1_width = L_in + thickness - oneSixteenth_in; const panel2_width = W_in + thickness; const panel3_width = L_in + thickness; const panel4_width = W_in + thickness - oneSixteenth_in;
                    const x_inner_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width; const x_outer_glue_tab = x_inner_glue_tab + glueFlap_in; const x_panel4_end_before_glue_tab = panel1_width + panel2_width + panel3_width + panel4_width;
                    const internalH_for_blank = H_in + (1 * thickness);
                    const halfW = W_in / 2; const halfCal = thickness / 2;
                    const flapLength_inches = roundToNearestFraction(halfW, 1/16) + roundToNearestFraction(halfCal, 1/16);
                    const blankWidth = x_outer_glue_tab; const blankHeight = internalH_for_blank + flapLength_inches;
                    const angleOffset = Math.tan(angle15DegRad) * glueFlap_in;
                    const y_top_body_crease = 0; const y_bottom_body_crease = internalH_for_blank;
                    const glueTabPoints = [ { x: x_inner_glue_tab, y: y_top_body_crease }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_inner_glue_tab, y: y_bottom_body_crease } ];
                    const dxfGlueTabPerimeterPoints = [ { x: x_panel4_end_before_glue_tab, y: y_bottom_body_crease }, { x: x_outer_glue_tab, y: y_bottom_body_crease - angleOffset }, { x: x_outer_glue_tab, y: y_top_body_crease + angleOffset }, { x: x_panel4_end_before_glue_tab, y: y_top_body_crease } ];
                    const glueTabScoreLine = { x1: x_inner_glue_tab, y1: y_top_body_crease, x2: x_inner_glue_tab, y2: y_bottom_body_crease };
                    const outsideDimensions = { length: L_in + (2 * thickness), width: W_in + (2 * thickness), height: H_in + (2 * thickness) };
                    const slots = [ { x: panel1_width - (slotWidth_full_in / 2), y: internalH_for_blank, w: slotWidth_full_in, h: flapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width) - (slotWidth_full_in / 2), y: internalH_for_blank, w: slotWidth_full_in, h: flapLength_inches, type: 'full' }, { x: (panel1_width + panel2_width + panel3_width) - (slotWidth_full_in / 2), y: internalH_for_blank, w: slotWidth_full_in, h: flapLength_inches, type: 'full' }, { x: x_inner_glue_tab - slotWidth_half_in, y: internalH_for_blank, w: slotWidth_half_in, h: flapLength_inches, type: 'half_right_open' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: 0, w: panel1_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width, y: 0, w: panel2_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width, y: 0, w: panel3_width, h: internalH_for_blank, type: 'panel' }, { x: panel1_width + panel2_width + panel3_width, y: 0, w: panel4_width, h: internalH_for_blank, type: 'panel' }, { points: glueTabPoints, type: 'polygon_cut' }, { x: 0, y: internalH_for_blank, w: panel1_width, h: flapLength_inches, type: 'flap' }, { x: panel1_width, y: internalH_for_blank, w: panel2_width, h: flapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width, y: internalH_for_blank, w: panel3_width, h: flapLength_inches, type: 'flap' }, { x: panel1_width + panel2_width + panel3_width, y: internalH_for_blank, w: panel4_width, h: flapLength_inches, type: 'flap' }, ], scoreLines: [ { x1: panel1_width, y1: 0, x2: panel1_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width, y1: 0, x2: panel1_width + panel2_width, y2: blankHeight, type: 'vertical' }, { x1: panel1_width + panel2_width + panel3_width, y1: 0, x2: panel1_width + panel2_width + panel3_width, y2: blankHeight, type: 'vertical' }, { x1: glueTabScoreLine.x1, y1: glueTabScoreLine.y1, x2: glueTabScoreLine.x2, y2: glueTabScoreLine.y2, type: 'vertical_glue_tab' }, { x1: 0, y1: internalH_for_blank, x2: blankWidth, y2: internalH_for_blank, type: 'horizontal' }, ], slots, dxfGlueTabPerimeterPoints };
                }
            },
            '0301_TRAY': { // Tray
                name: '0301 Design Style Tray (Base)',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const D = H_in; const CAL = thickness; const frac = 1/16; const slot_width = 3/8;
                    const flap_H = roundToNearestFraction(D + 0.5 * CAL, frac); const flap_W = roundToNearestFraction(D + 0.5 * CAL, frac);
                    const center_L = roundToNearestFraction(L_in + 2 * CAL, frac); const center_W = roundToNearestFraction(W_in + 1 * CAL, frac);
                    const blankWidth = flap_W + center_L + flap_W; const blankHeight = flap_H + center_W + flap_H;
                    const outsideDimensions = { length: center_L, width: center_W, height: flap_H };
                    const slots = [ { x: flap_W - (slot_width / 2), y: 0, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W + center_L - (slot_width / 2), y: 0, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W - (slot_width / 2), y: flap_H + center_W, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W + center_L - (slot_width / 2), y: flap_H + center_W, w: slot_width, h: flap_H, type: 'full' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: 0, w: blankWidth, h: blankHeight, type: 'panel' } ], scoreLines: [ { x1: flap_W, y1: 0, x2: flap_W, y2: blankHeight, type: 'vertical' }, { x1: flap_W + center_L, y1: 0, x2: flap_W + center_L, y2: blankHeight, type: 'vertical' }, { x1: 0, y1: flap_H, x2: blankWidth, y2: flap_H, type: 'horizontal' }, { x1: 0, y1: flap_H + center_W, x2: blankWidth, y2: flap_H + center_W, type: 'horizontal' }, ], slots, dxfGlueTabPerimeterPoints: [] };
                }
            },
            '0301_LID': { // Lid
                name: '0301 Design Style Lid',
                calculateBlank: (L_in, W_in, H_in, thickness) => {
                    const D = H_in; const CAL = thickness; const frac = 1/16; const slot_width = 3/8;
                    const flap_H = roundToNearestFraction(D + 1.5 * CAL, frac); const flap_W = roundToNearestFraction(D + 1.5 * CAL, frac);
                    const center_L = roundToNearestFraction(W_in + 7 * CAL, frac); const center_W = roundToNearestFraction(L_in + 5 * CAL, frac);
                    const blankWidth = flap_W + center_L + flap_W; const blankHeight = flap_H + center_W + flap_H;
                    const outsideDimensions = { length: center_L, width: center_W, height: flap_H };
                    const slots = [ { x: flap_W - (slot_width / 2), y: 0, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W + center_L - (slot_width / 2), y: 0, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W - (slot_width / 2), y: flap_H + center_W, w: slot_width, h: flap_H, type: 'full' }, { x: flap_W + center_L - (slot_width / 2), y: flap_H + center_W, w: slot_width, h: flap_H, type: 'full' } ];
                    return { blankWidth, blankHeight, outsideDimensions, layout: [ { x: 0, y: 0, w: blankWidth, h: blankHeight, type: 'panel' } ], scoreLines: [ { x1: flap_W, y1: 0, x2: flap_W, y2: blankHeight, type: 'vertical' }, { x1: flap_W + center_L, y1: 0, x2: flap_W + center_L, y2: blankHeight, type: 'vertical' }, { x1: 0, y1: flap_H, x2: blankWidth, y2: flap_H, type: 'horizontal' }, { x1: 0, y1: flap_H + center_W, x2: blankWidth, y2: flap_H + center_W, type: 'horizontal' }, ], slots, dxfGlueTabPerimeterPoints: [] };
                }
            },
        };

        const getCleanedLineSegments = (line, cutRects, glueTabInternalPoints) => {
            const xTolerance = 1e-6;
            const isVertical = line.type.startsWith('vertical');
            const isGlueTabScoreLine = line.type === 'vertical_glue_tab';

            let segments = [{
                start: isVertical ? line.y1 : line.x1,
                end: isVertical ? line.y2 : line.x2,
            }];

            const clipSegments = (currentSegments, clipArea) => {
                let nextSegments = [];
                currentSegments.forEach(seg => {
                    const overlapStart = Math.max(seg.start, clipArea.start);
                    const overlapEnd = Math.min(seg.end, clipArea.end);

                    if (overlapStart < overlapEnd - xTolerance) {
                        if (seg.start < overlapStart - xTolerance) {
                            nextSegments.push({ start: seg.start, end: overlapStart });
                        }
                        if (seg.end > overlapEnd + xTolerance) {
                            nextSegments.push({ start: overlapEnd, end: seg.end });
                        }
                    } else {
                        nextSegments.push(seg);
                    }
                });
                return nextSegments;
            };
            
            cutRects.forEach(rect => {
                let clipArea;
                if (isVertical && line.x1 >= rect.x - xTolerance && line.x1 <= rect.x + rect.w + xTolerance) {
                    clipArea = { start: rect.y, end: rect.y + rect.h };
                    segments = clipSegments(segments, clipArea);
                } else if (!isVertical && line.y1 >= rect.y - xTolerance && line.y1 <= rect.y + rect.h + xTolerance) {
                    clipArea = { start: rect.x, end: rect.x + rect.w };
                    segments = clipSegments(segments, clipArea);
                }
            });
            
            if (!isGlueTabScoreLine && glueTabInternalPoints.length === 4) {
                const polyP1 = glueTabInternalPoints[0]; const polyP2 = glueTabInternalPoints[1]; const polyP3 = glueTabInternalPoints[2]; const polyP4 = glueTabInternalPoints[3];
                if (isVertical) {
                    if (line.x1 > polyP1.x - xTolerance) {
                        const slopeTop = (polyP2.y - polyP1.y) / (polyP2.x - polyP1.x);
                        const yGlueTabTop = polyP1.y + slopeTop * (line.x1 - polyP1.x);
                        const slopeBottom = (polyP3.y - polyP4.y) / (polyP3.x - polyP4.x);
                        const yGlueTabBottom = polyP4.y + slopeBottom * (line.x1 - polyP4.x);
                        const clipArea = { start: Math.min(yGlueTabTop, yGlueTabBottom), end: Math.max(yGlueTabTop, yGlueTabBottom) };
                        segments = clipSegments(segments, clipArea);
                    }
                } else {
                    const clipArea = { start: polyP1.x, end: line.x2 };
                    segments = clipSegments(segments, clipArea);
                }
            }
            
            return segments.map(seg => {
                if (isVertical) {
                    return { x1: line.x1, y1: seg.start, x2: line.x1, y2: seg.end };
                } else {
                    return { x1: seg.start, y1: line.y1, x2: seg.end, y2: line.y1 };
                }
            }).filter(l => (Math.abs(l.x1 - l.x2) > xTolerance || Math.abs(l.y1 - l.y2) > xTolerance));
        };
        
        const generateDxfContent = (blankData, fefcoStyle, L_in, W_in, H_in) => {
            let dxf = `0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1009\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n`;
            const xTolerance = 1e-6;

            const addLine = (color, x1, y1, x2, y2) => {
                if (Math.abs(x1 - x2) > xTolerance || Math.abs(y1 - y2) > xTolerance) {
                    dxf += `0\nLINE\n8\n0\n62\n${color}\n10\n${x1.toFixed(6)}\n20\n${(blankData.blankHeight - y1).toFixed(6)}\n30\n0\n11\n${x2.toFixed(6)}\n21\n${(blankData.blankHeight - y2).toFixed(6)}\n31\n0\n`;
                }
            };
            
            const y_top_edge = 0; const y_bottom_edge = blankData.blankHeight; const x_left_edge = 0; const x_right_edge = blankData.blankWidth;
            const x_inner_glue_tab = blankData.dxfGlueTabPerimeterPoints.length > 0 ? blankData.dxfGlueTabPerimeterPoints[0].x : blankData.blankWidth;
            const dxfGlueTabPerimeterPoints = blankData.dxfGlueTabPerimeterPoints || [];
            const glueTabStyles = ['0201', '0203', '0200_HSC'];
            const isGlueTabStyle = glueTabStyles.includes(fefcoStyle);

            if (isGlueTabStyle && dxfGlueTabPerimeterPoints.length === 4) {
                const p1 = dxfGlueTabPerimeterPoints[0]; const p2 = dxfGlueTabPerimeterPoints[1]; const p3 = dxfGlueTabPerimeterPoints[2]; const p4 = dxfGlueTabPerimeterPoints[3];
                addLine(1, p1.x, p1.y, p2.x, p2.y); addLine(1, p2.x, p2.y, p3.x, p3.y); addLine(1, p3.x, p3.y, p4.x, p4.y);
            }

            const topSlots = blankData.slots.filter(s => Math.abs(s.y - y_top_edge) < xTolerance).sort((a, b) => a.x - b.x);
            let lastX_top = 0;
            topSlots.forEach(slot => { if (slot.x > lastX_top + xTolerance) addLine(1, lastX_top, y_top_edge, slot.x, y_top_edge); lastX_top = slot.x + slot.w; });
            const topXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
            if (lastX_top < topXLimit - xTolerance) addLine(1, lastX_top, y_top_edge, topXLimit, y_top_edge);

            const bottomSlots = blankData.slots.filter(s => Math.abs(s.y + s.h - y_bottom_edge) < xTolerance).sort((a, b) => a.x - b.x);
            let lastX_bottom = 0;
            bottomSlots.forEach(slot => { if (slot.x > lastX_bottom + xTolerance) addLine(1, lastX_bottom, y_bottom_edge, slot.x, y_bottom_edge); lastX_bottom = slot.x + slot.w; });
            const bottomXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
            if (lastX_bottom < bottomXLimit - xTolerance) addLine(1, lastX_bottom, y_bottom_edge, bottomXLimit, y_bottom_edge);

            const leftSlots = blankData.slots.filter(s => Math.abs(s.x - x_left_edge) < xTolerance).sort((a, b) => a.y - b.y);
            let lastY_left = 0;
            leftSlots.forEach(slot => { if (slot.y > lastY_left + xTolerance) addLine(1, x_left_edge, lastY_left, x_left_edge, slot.y); lastY_left = slot.y + slot.h; });
            if (lastY_left < y_bottom_edge - xTolerance) addLine(1, x_left_edge, lastY_left, x_left_edge, y_bottom_edge);
            
            if (!isGlueTabStyle) {
                const rightSlots = blankData.slots.filter(s => Math.abs(s.x + s.w - x_right_edge) < xTolerance).sort((a, b) => a.y - b.y);
                let lastY_right = 0;
                rightSlots.forEach(slot => { if (slot.y > lastY_right + xTolerance) addLine(1, x_right_edge, lastY_right, x_right_edge, slot.y); lastY_right = slot.y + slot.h; });
                if (lastY_right < y_bottom_edge - xTolerance) addLine(1, x_right_edge, lastY_right, x_right_edge, y_bottom_edge);
            }
            
            blankData.slots.forEach(slot => {
                if (slot.type === 'full') { addLine(1, slot.x, slot.y, slot.x, slot.y + slot.h); addLine(1, slot.x + slot.w, slot.y, slot.x + slot.w, slot.y + slot.h); const hLineY = Math.abs(slot.y - y_top_edge) < xTolerance ? slot.y + slot.h : slot.y; addLine(1, slot.x, hLineY, slot.x + slot.w, hLineY); } 
                else if (slot.type === 'half_right_open') { addLine(1, slot.x, slot.y, slot.x, slot.y + slot.h); const hLineY = Math.abs(slot.y - y_top_edge) < xTolerance ? slot.y + slot.h : slot.y; addLine(1, slot.x, hLineY, x_inner_glue_tab, hLineY); }
            });

            const cutRects = blankData.slots.map(s => s.type !== 'line_cut' ? { x: s.x, y: s.y, w: s.w, h: s.h } : null).filter(Boolean);
            const glueTabInternalPoints = blankData.layout.find(p => p.type === 'polygon_cut')?.points || [];
            blankData.scoreLines.forEach(line => {
                const cleanedSegments = getCleanedLineSegments(line, cutRects, glueTabInternalPoints);
                cleanedSegments.forEach(seg => { addLine(3, seg.x1, seg.y1, seg.x2, seg.y2); });
            });

            dxf += `0\nENDSEC\n0\nEOF`;
            return dxf;
        };

        const generatePdf = (blankData, fefcoStyle, L_in, W_in, H_in, unit, setMessage) => {
            const { jsPDF } = window.jspdf;
            const pdfUnit = 'in'; // Hardcoding to inches for simplicity with v0.8
            const margin = 0.5;
            const pdfPageWidth = blankData.blankWidth + (2 * margin);
            const pdfPageHeight = blankData.blankHeight + (2 * margin);

            const doc = new jsPDF({ orientation: pdfPageWidth > pdfPageHeight ? 'landscape' : 'portrait', unit: pdfUnit, format: [pdfPageWidth, pdfPageHeight] });
            const xTolerance = 1e-6;

            const addLineToPdf = (x1, y1, x2, y2) => { doc.line(x1 + margin, y1 + margin, x2 + margin, y2 + margin); };

            doc.setTextColor(0, 0, 0); doc.setFontSize(10);
            doc.text(`FEFCO ${fefcoStyle} - L:${L_in.toFixed(3)} W:${W_in.toFixed(3)} H:${H_in.toFixed(3)} (${pdfUnit})`, margin, margin / 2);
            doc.text(`Blank: ${blankData.blankWidth.toFixed(3)} x ${blankData.blankHeight.toFixed(3)} ${pdfUnit}`, margin, margin/2 + 0.2);
            
            doc.setDrawColor(255, 0, 0); doc.setLineDashPattern([], 0); doc.setLineWidth(0.02);

            const y_top_edge = 0; const y_bottom_edge = blankData.blankHeight; const x_left_edge = 0; const x_right_edge = blankData.blankWidth;
            const x_inner_glue_tab = blankData.dxfGlueTabPerimeterPoints.length > 0 ? blankData.dxfGlueTabPerimeterPoints[0].x : blankData.blankWidth;
            const dxfGlueTabPerimeterPoints = blankData.dxfGlueTabPerimeterPoints || [];
            const glueTabStyles = ['0201', '0203', '0200_HSC'];
            const isGlueTabStyle = glueTabStyles.includes(fefcoStyle);

            if (isGlueTabStyle && dxfGlueTabPerimeterPoints.length === 4) {
                const p1 = dxfGlueTabPerimeterPoints[0]; const p2 = dxfGlueTabPerimeterPoints[1]; const p3 = dxfGlueTabPerimeterPoints[2]; const p4 = dxfGlueTabPerimeterPoints[3];
                addLineToPdf(p1.x, p1.y, p2.x, p2.y); addLineToPdf(p2.x, p2.y, p3.x, p3.y); addLineToPdf(p3.x, p3.y, p4.x, p4.y);
            }

            const topSlots = blankData.slots.filter(s => Math.abs(s.y - y_top_edge) < xTolerance).sort((a, b) => a.x - b.x);
            let lastX_top = 0;
            topSlots.forEach(slot => { if (slot.x > lastX_top + xTolerance) addLineToPdf(lastX_top, y_top_edge, slot.x, y_top_edge); lastX_top = slot.x + slot.w; });
            const topXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
            if (lastX_top < topXLimit - xTolerance) addLineToPdf(lastX_top, y_top_edge, topXLimit, y_top_edge);

            const bottomSlots = blankData.slots.filter(s => Math.abs(s.y + s.h - y_bottom_edge) < xTolerance).sort((a, b) => a.x - b.x);
            let lastX_bottom = 0;
            bottomSlots.forEach(slot => { if (slot.x > lastX_bottom + xTolerance) addLineToPdf(lastX_bottom, y_bottom_edge, slot.x, y_bottom_edge); lastX_bottom = slot.x + slot.w; });
            const bottomXLimit = isGlueTabStyle ? x_inner_glue_tab : x_right_edge;
            if (lastX_bottom < bottomXLimit - xTolerance) addLineToPdf(lastX_bottom, y_bottom_edge, bottomXLimit, y_bottom_edge);

            const leftSlots = blankData.slots.filter(s => Math.abs(s.x - x_left_edge) < xTolerance).sort((a, b) => a.y - b.y);
            let lastY_left = 0;
            leftSlots.forEach(slot => { if (slot.y > lastY_left + xTolerance) addLineToPdf(x_left_edge, lastY_left, x_left_edge, slot.y); lastY_left = slot.y + slot.h; });
            if (lastY_left < y_bottom_edge - xTolerance) addLineToPdf(x_left_edge, lastY_left, x_left_edge, y_bottom_edge);
            
            if (!isGlueTabStyle) {
                const rightSlots = blankData.slots.filter(s => Math.abs(s.x + s.w - x_right_edge) < xTolerance).sort((a, b) => a.y - b.y);
                let lastY_right = 0;
                rightSlots.forEach(slot => { if (slot.y > lastY_right + xTolerance) addLineToPdf(x_right_edge, lastY_right, x_right_edge, slot.y); lastY_right = slot.y + slot.h; });
                if (lastY_right < y_bottom_edge - xTolerance) addLineToPdf(x_right_edge, lastY_right, x_right_edge, y_bottom_edge);
            }
            
            blankData.slots.forEach(slot => {
                if (slot.type === 'full') { addLineToPdf(slot.x, slot.y, slot.x, slot.y + slot.h); addLineToPdf(slot.x + slot.w, slot.y, slot.x + slot.w, slot.y + slot.h); const hLineY = Math.abs(slot.y - y_top_edge) < xTolerance ? slot.y + slot.h : slot.y; addLineToPdf(slot.x, hLineY, slot.x + slot.w, hLineY); } 
                else if (slot.type === 'half_right_open') { addLineToPdf(slot.x, slot.y, slot.x, slot.y + slot.h); const hLineY = Math.abs(slot.y - y_top_edge) < xTolerance ? slot.y + slot.h : slot.y; addLineToPdf(slot.x, hLineY, x_inner_glue_tab, hLineY); }
            });

            doc.setDrawColor(0, 177, 64); doc.setLineDashPattern([0.08, 0.04], 0); doc.setLineWidth(0.02);
            const cutRects = blankData.slots.map(s => s.type !== 'line_cut' ? { x: s.x, y: s.y, w: s.w, h: s.h } : null).filter(Boolean);
            const glueTabInternalPoints = blankData.layout.find(p => p.type === 'polygon_cut')?.points || [];
            blankData.scoreLines.forEach(line => {
                const cleanedSegments = getCleanedLineSegments(line, cutRects, glueTabInternalPoints);
                cleanedSegments.forEach(seg => { addLineToPdf(seg.x1, seg.y1, seg.x2, seg.y2); });
            });

            doc.save(`FEFCO_${fefcoStyle}_${L_in.toFixed(2)}x${W_in.toFixed(2)}x${H_in.toFixed(2)}.pdf`);
            setMessage('PDF file downloaded successfully!');
        };
        // --- End of STABLE Geometry and Drawing Engine ---


        // --- Main React Application Component ---
        const FEFCOCADApp = () => {
            // CAD State
            const [length, setLength] = useState(13.5);
            const [width, setWidth] = useState(9.75);
            const [height, setHeight] = useState(10.75);
            const [boardProfile, setBoardProfile] = useState('32 ECT B');
            const [fefcoStyle, setFefcoStyle] = useState('0201');
            const [blankDimensions, setBlankDimensions] = useState(null);
            const [outsideDimensions, setOutsideDimensions] = useState(null);
            const [squareFootage, setSquareFootage] = useState(null);
            const [wastePercentage, setWastePercentage] = useState(null);

            // Estimating State
            const [priceMsf, setPriceMsf] = useState(48);
            const [outerLiner, setOuterLiner] = useState(35);
            const [innerLiner, setInnerLiner] = useState(35);
            const [medium, setMedium] = useState(23);
            const [flute, setFlute] = useState(1.42); // Take-up Factor
            const [margin, setMargin] = useState(20);
            const [printUpcharge, setPrintUpcharge] = useState(0.05);
            const [setupFee, setSetupFee] = useState(350);
            const [quantity, setQuantity] = useState(5000);
            const [quoteResults, setQuoteResults] = useState(null);

            const [message, setMessage] = useState('');
            const canvasRef = useRef(null);
            
            const runCalculations = useCallback(() => {
                const L_in = parseFloat(length);
                const W_in = parseFloat(width);
                const H_in = parseFloat(height);

                if (isNaN(L_in) || isNaN(W_in) || isNaN(H_in) || L_in <= 0 || W_in <= 0 || H_in <= 0) {
                    setMessage('Please enter valid positive numbers for all CAD dimensions.');
                    setBlankDimensions(null); setQuoteResults(null); setOutsideDimensions(null); setSquareFootage(null); setWastePercentage(null);
                    return;
                }
                
                const stylesWithFlapMeeting = ['0201', '0203', '0200_HSC'];
                if (stylesWithFlapMeeting.includes(fefcoStyle) && L_in < W_in) {
                    setMessage('Error: For this style, Length (L) must be >= Width (W).');
                    setBlankDimensions(null); setQuoteResults(null); setOutsideDimensions(null); setSquareFootage(null); setWastePercentage(null);
                    return;
                }

                const thickness_in = boardProfiles[boardProfile];
                const selectedStyle = fefcoStyles[fefcoStyle];

                if (!selectedStyle) {
                    setMessage('Please select a valid FEFCO style.');
                    setBlankDimensions(null); setQuoteResults(null); setOutsideDimensions(null); setSquareFootage(null); setWastePercentage(null);
                    return;
                }
                
                const blankData = selectedStyle.calculateBlank(L_in, W_in, H_in, thickness_in);
                setBlankDimensions(blankData);
                setOutsideDimensions(blankData.outsideDimensions);
                drawBlank(blankData);
                
                const blankAreaSqIn = blankData.blankWidth * blankData.blankHeight;
                const blankAreaSqFt = blankAreaSqIn / 144;
                setSquareFootage(blankAreaSqFt);

                let waste = 0;
                if (blankAreaSqIn > 0) {
                     if (fefcoStyle.startsWith('0301')) {
                        let totalSlotArea_sq_in = 0;
                        const D = H_in; const CAL = thickness_in; const frac = 1/16;
                        const flap_H = roundToNearestFraction(D + 0.5 * CAL, frac);
                        const slot_width = 3/8;
                        totalSlotArea_sq_in = 4 * flap_H * slot_width;
                        waste = (totalSlotArea_sq_in / blankAreaSqIn) * 100;
                    } else {
                        const glueFlap_in = 1.375;
                        let flapLength_for_waste = 0;
                        if (['0201', '0200_HSC'].includes(fefcoStyle)) {
                            flapLength_for_waste = roundToNearestFraction(W_in / 2, 1/16) + roundToNearestFraction(thickness_in / 2, 1/16);
                        } else if (fefcoStyle === '0203') {
                            flapLength_for_waste = W_in;
                        }
                        const trimmedArea_sq_in = glueFlap_in * flapLength_for_waste * 2;
                        waste = (trimmedArea_sq_in / blankAreaSqIn) * 100;
                        let totalSlotArea_sq_in_other_styles = 0;
                        blankData.slots.forEach(slot => {
                            totalSlotArea_sq_in_other_styles += slot.w * slot.h;
                        });
                        waste += (totalSlotArea_sq_in_other_styles / blankAreaSqIn) * 100;
                    }
                }
                setWastePercentage(waste);
                
                const pricingInputs = {
                    outerLiner: parseFloat(outerLiner) || 0,
                    innerLiner: parseFloat(innerLiner) || 0,
                    medium: parseFloat(medium) || 0,
                    takeUpFactor: parseFloat(flute) || 0,
                    priceMsf: parseFloat(priceMsf) || 0,
                    blankAreaSqFt: blankAreaSqFt,
                    quantity: parseInt(quantity) || 0,
                    marginPercent: parseFloat(margin) || 0,
                    printUpcharge: parseFloat(printUpcharge) || 0,
                    setupFee: parseFloat(setupFee) || 0,
                };
                
                const results = estimatingEngine.calculate(pricingInputs);
                setQuoteResults(results);
                
                setMessage(`Generated blank for FEFCO ${fefcoStyle}: ${selectedStyle.name}`);

            }, [length, width, height, boardProfile, fefcoStyle, priceMsf, outerLiner, innerLiner, medium, flute, margin, printUpcharge, setupFee, quantity]);


            useEffect(() => {
                runCalculations();
            }, [runCalculations]);

            const drawBlank = (blank) => {
                const canvas = canvasRef.current;
                if (!canvas || !blank) return;
                const ctx = canvas.getContext('2d');
                const parentWidth = canvas.parentElement.clientWidth;
                const scale = parentWidth / (blank.blankWidth + 1);
                
                canvas.width = (blank.blankWidth + 1) * scale;
                canvas.height = (blank.blankHeight + 1) * scale;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 0.5 * scale;
                ctx.translate(padding, padding);
                ctx.scale(scale, scale);

                blank.layout.forEach(part => {
                    if (part.type === 'panel' || part.type === 'flap') {
                        ctx.fillStyle = part.type === 'panel' ? '#D4EDDA' : '#C3E6CB';
                        ctx.fillRect(part.x, part.y, part.w, part.h);
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 1 / scale;
                        ctx.strokeRect(part.x, part.y, part.w, part.h);
                    } else if (part.type === 'polygon_cut') {
                        ctx.fillStyle = '#B8DAFF';
                        ctx.beginPath();
                        ctx.moveTo(part.points[0].x, part.points[0].y);
                        for (let i = 1; i < part.points.length; i++) {
                            ctx.lineTo(part.points[i].x, part.points[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 1 / scale;
                        ctx.stroke();
                    }
                });

                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 1 / scale;
                ctx.setLineDash([5 / scale, 5 / scale]);
                blank.scoreLines.forEach(line => {
                    const cutRects = blank.slots.map(s => s.type !== 'line_cut' ? { x: s.x, y: s.y, w: s.w, h: s.h } : null).filter(Boolean);
                    const glueTabInternalPoints = blank.layout.find(p => p.type === 'polygon_cut')?.points || [];
                    const cleanedSegments = getCleanedLineSegments(line, cutRects, glueTabInternalPoints);
                    cleanedSegments.forEach(seg => {
                        ctx.beginPath();
                        ctx.moveTo(seg.x1, seg.y1);
                        ctx.lineTo(seg.x2, seg.y2);
                        ctx.stroke();
                    });
                });
                ctx.setLineDash([]);

                const x_inner_glue_tab_canvas = blank.dxfGlueTabPerimeterPoints.length > 0 ? blank.dxfGlueTabPerimeterPoints[0].x : 0;
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 1 / scale;
                blank.slots.forEach(slot => {
                    ctx.beginPath();
                    if (slot.type === 'full' || slot.type === 'half_right_open') {
                        ctx.moveTo(slot.x, slot.y);
                        ctx.lineTo(slot.x, slot.y + slot.h);
                        if (slot.type !== 'half_right_open') {
                            ctx.moveTo(slot.x + slot.w, slot.y);
                            ctx.lineTo(slot.x + slot.w, slot.y + slot.h);
                        }
                        const hLineY = Math.abs(slot.y) < 1e-6 ? slot.y + slot.h : slot.y;
                        const hLineX2 = slot.type === 'half_right_open' ? x_inner_glue_tab_canvas : slot.x + slot.w;
                        ctx.moveTo(slot.x, hLineY);
                        ctx.lineTo(hLineX2, hLineY);
                    }
                    ctx.stroke();
                });
            };

            const handleDownload = (type) => {
                if (!blankDimensions) {
                    setMessage(`Please generate the CAD first before downloading.`);
                    return;
                }
                const L_in = parseFloat(length);
                const W_in = parseFloat(width);
                const H_in = parseFloat(height);
                const thickness_in = boardProfiles[boardProfile];
                const blankData = fefcoStyles[fefcoStyle].calculateBlank(L_in, W_in, H_in, thickness_in);

                if (type === 'dxf') {
                    const dxfContent = generateDxfContent(blankData, fefcoStyle, L_in, W_in, H_in);
                    const blob = new Blob([dxfContent], { type: 'application/dxf' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `FEFCO_${fefcoStyle}_${L_in.toFixed(2)}x${W_in.toFixed(2)}x${H_in.toFixed(2)}.dxf`;
                    a.click();
                    URL.revokeObjectURL(url);
                    a.remove();
                    setMessage('DXF file downloaded successfully!');
                } else if (type === 'pdf') {
                    generatePdf(blankData, fefcoStyle, L_in, W_in, H_in, 'inch', setMessage);
                }
            };

            return (
                <div className="max-w-7xl mx-auto p-4 md:p-8">
                    <div className="text-center mb-8">
                        <h1 className="text-4xl md:text-5xl font-extrabold text-slate-800 flex items-baseline justify-center">
                            <span>corru</span>
                            <span className="text-orange-500 text-5xl md:text-6xl font-normal mx-1" style={{ transform: 'translateY(2px)' }}>~</span>
                            <span className="font-black">CAD</span>
                        </h1>
                        <p className="text-md text-gray-600">v0.8 Precision Estimating (w/ Fixed Geometry Engine)</p>
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                        <div className="lg:col-span-2 bg-white p-6 rounded-lg shadow-sm space-y-6">
                            <div>
                                <h2 className="section-title">CAD Inputs</h2>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div>
                                        <label htmlFor="length" className="block text-sm font-medium text-gray-700">Length (L) (in)</label>
                                        <input type="number" id="length" value={length} onChange={e => setLength(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"/>
                                    </div>
                                    <div>
                                        <label htmlFor="width" className="block text-sm font-medium text-gray-700">Width (W) (in)</label>
                                        <input type="number" id="width" value={width} onChange={e => setWidth(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"/>
                                    </div>
                                    <div>
                                        <label htmlFor="height" className="block text-sm font-medium text-gray-700">Height (H) (in)</label>
                                        <input type="number" id="height" value={height} onChange={e => setHeight(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"/>
                                    </div>
                                    <div className="md:col-span-2">
                                        <label htmlFor="fefcoStyle" className="block text-sm font-medium text-gray-700">FEFCO Style</label>
                                        <select id="fefcoStyle" value={fefcoStyle} onChange={e => setFefcoStyle(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                            {Object.keys(fefcoStyles).map(style => <option key={style} value={style}>{style} - {fefcoStyles[style].name}</option>)}
                                        </select>
                                    </div>
                                    <div>
                                        <label htmlFor="boardProfile" className="block text-sm font-medium text-gray-700">Board</label>
                                        <select id="boardProfile" value={boardProfile} onChange={e => setBoardProfile(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                                {Object.keys(boardProfiles).map(profile => <option key={profile} value={profile}>{profile}</option>)}
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <div>
                                <h2 className="section-title">Precision Estimating Inputs</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div className="space-y-4 p-4 border rounded-md bg-gray-50">
                                        <h3 className="font-semibold text-gray-700">Material Definition</h3>
                                        <div>
                                            <label htmlFor="priceMsf" className="block text-sm font-medium text-gray-700">Market Price ($/msf)</label>
                                            <input type="number" id="priceMsf" value={priceMsf} onChange={e => setPriceMsf(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                        </div>
                                        <div className="grid grid-cols-2 gap-2">
                                            <div>
                                                <label htmlFor="outerLiner" className="block text-sm font-medium text-gray-700">Outer Liner</label>
                                                <input type="number" id="outerLiner" value={outerLiner} onChange={e => setOuterLiner(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                            </div>
                                            <div>
                                                <label htmlFor="innerLiner" className="block text-sm font-medium text-gray-700">Inner Liner</label>
                                                <input type="number" id="innerLiner" value={innerLiner} onChange={e => setInnerLiner(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                            </div>
                                            <div>
                                                <label htmlFor="medium" className="block text-sm font-medium text-gray-700">Medium</label>
                                                <input type="number" id="medium" value={medium} onChange={e => setMedium(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                            </div>
                                            <div>
                                                <label htmlFor="flute" className="block text-sm font-medium text-gray-700">Flute</label>
                                                <select id="flute" value={flute} onChange={e => setFlute(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md">
                                                    <option value="1.42">C Flute</option>
                                                    <option value="1.32">B Flute</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                    <div className="space-y-4 p-4 border rounded-md bg-gray-50">
                                        <h3 className="font-semibold text-gray-700">Quote Details</h3>
                                        <div>
                                            <label htmlFor="margin" className="block text-sm font-medium text-gray-700">Margin (%)</label>
                                            <input type="number" id="margin" value={margin} onChange={e => setMargin(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                        </div>
                                        <div>
                                            <label htmlFor="printUpcharge" className="block text-sm font-medium text-gray-700">Printing ($/box)</label>
                                            <input type="number" id="printUpcharge" value={printUpcharge} onChange={e => setPrintUpcharge(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                        </div>
                                        <div>
                                            <label htmlFor="setupFee" className="block text-sm font-medium text-gray-700">Setup Fee ($)</label>
                                            <input type="number" id="setupFee" value={setupFee} onChange={e => setSetupFee(e.target.value)} className="mt-1 block w-full p-2 border border-gray-300 rounded-md"/>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="bg-white p-6 rounded-lg shadow-sm space-y-6">
                                <h2 className="section-title">Quote Summary</h2>
                            {message && <div className="text-sm p-3 rounded-md bg-blue-50 text-blue-700">{message}</div>}
                            <div className="bg-gray-50 p-4 rounded-md">
                                <h3 className="font-semibold text-gray-700 mb-2">CAD Output</h3>
                                {blankDimensions && outsideDimensions ? (
                                    <div className="bg-white p-4 rounded-md shadow-inner text-sm space-y-1 mb-4">
                                        <h3 className="font-semibold text-gray-800 mb-2">Calculated Dimensions:</h3>
                                        <div className="grid grid-cols-2 gap-x-4">
                                            <span>Internal L:</span><span className="font-medium text-right">{parseFloat(length).toFixed(3)} in</span>
                                            <span>Internal W:</span><span className="font-medium text-right">{parseFloat(width).toFixed(3)} in</span>
                                            <span>Internal H:</span><span className="font-medium text-right">{parseFloat(height).toFixed(3)} in</span>
                                        </div>
                                        <div className="border-t my-2"></div>
                                        <div className="grid grid-cols-2 gap-x-4">
                                            <span>Outside L:</span><span className="font-medium text-right">{outsideDimensions.length.toFixed(3)} in</span>
                                            <span>Outside W:</span><span className="font-medium text-right">{outsideDimensions.width.toFixed(3)} in</span>
                                            <span>Outside H:</span><span className="font-medium text-right">{outsideDimensions.height.toFixed(3)} in</span>
                                        </div>
                                        <div className="border-t my-2"></div>
                                        <div className="grid grid-cols-2 gap-x-4">
                                            <span>Blank W:</span><span className="font-medium text-right">{blankDimensions.blankWidth.toFixed(3)} in</span>
                                            <span>Blank H:</span><span className="font-medium text-right">{blankDimensions.blankHeight.toFixed(3)} in</span>
                                        </div>
                                        <div className="border-t my-2"></div>
                                        <div className="grid grid-cols-2 gap-x-4 text-base">
                                            <span className="font-bold">Sq. Footage:</span><span className="font-bold text-right">{squareFootage ? squareFootage.toFixed(4) : 'N/A'} ft</span>
                                            <span className="font-bold">Est. Waste:</span><span className="font-bold text-right">{wastePercentage ? wastePercentage.toFixed(2) : 'N/A'}%</span>
                                        </div>
                                    </div>
                                ) : <div className="text-sm text-gray-500">Enter valid dimensions...</div>}
                                
                                <div className="mt-4 border rounded-md bg-white overflow-hidden">
                                        <canvas ref={canvasRef}></canvas>
                                </div>
                                <div className="grid grid-cols-2 gap-4 mt-4">
                                    <button onClick={() => handleDownload('dxf')} disabled={!blankDimensions} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md disabled:bg-gray-400">Download DXF</button>
                                    <button onClick={() => handleDownload('pdf')} disabled={!blankDimensions} className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md disabled:bg-gray-400">Download PDF</button>
                                </div>
                            </div>

                                <div className="bg-indigo-50 p-4 rounded-md">
                                <h3 className="font-semibold text-indigo-800 mb-2">Pricing Output</h3>
                                {quoteResults ? (
                                    <>
                                        <div className="space-y-2 text-sm text-indigo-900">
                                            <div className="flex justify-between"><span>Material Cost:</span><span className="font-medium">${quoteResults.baseMaterialCost.toFixed(4)}</span></div>
                                            <div className="flex justify-between"><span>Margin:</span><span className="font-medium">${quoteResults.marginAmount.toFixed(4)}</span></div>
                                            <div className="flex justify-between"><span>Printing:</span><span className="font-medium">${parseFloat(printUpcharge).toFixed(4)}</span></div>
                                            <div className="border-t border-indigo-200 my-1"></div>
                                            <div className="flex justify-between font-bold text-base"><span>Cost per Box:</span><span>${quoteResults.costPerBox.toFixed(4)}</span></div>
                                        </div>
                                        <div className="mt-4 text-center">
                                            <label htmlFor="quantity" className="block text-sm font-medium text-gray-700 mb-1">Quantity</label>
                                            <input type="number" id="quantity" value={quantity} onChange={e => setQuantity(e.target.value)} className="w-full p-2 rounded-md mb-2 border-gray-300"/>
                                            <div className="bg-white p-3 rounded-md">
                                                <span className="text-gray-600">Total Cost:</span>
                                                <span className="final-quote-value text-2xl font-bold ml-2">${quoteResults.totalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                                            </div>
                                        </div>
                                    </>
                                ) : <div className="text-sm text-indigo-700">Enter valid CAD dimensions to calculate a quote.</div>}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => <FEFCOCADApp />;
        const rootElement = document.getElementById('root');
        const root = createRoot(rootElement);
        root.render(<React.StrictMode><App /></React.StrictMode>);

    </script>
</body>
</html>